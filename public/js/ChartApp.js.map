{"version":3,"sources":["constants.js","App.Utils.js","App.Models.ChartModel.js","App.Models.ChartDataModel.js","App.Views.Chart.Header.js","App.Views.Chart.Footer.js","App.Views.Chart.ScaleSelectors.js","App.Views.Chart.Legend.js","App.Views.Chart.ChartTab.js","App.Views.Chart.DataTab.js","App.Views.Chart.SourcesTab.js","App.Views.Chart.Map.MapControls.js","App.Views.Chart.Map.PlayPauseControl.js","App.Views.Chart.Map.TimelineControl.js","App.Views.Chart.Map.ButtonsControl.js","App.Views.Chart.Map.TimelineControls.js","App.Views.Chart.Map.Projections.js","App.Views.Chart.Map.Legend.js","App.Views.Chart.MapTab.js","App.Views.ChartURL.js","App.Views.ChartView.js","ChartApp.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACznBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ChartApp.js","sourcesContent":[";(function() {\t\n\t\"use strict\";\n\n\twindow.App = window.App || {};\n\n\tApp.ChartType = {\n\t\tLineChart: 1,\n\t\tScatterPlot: 2,\n\t\tStackedArea: 3,\n\t\tMultiBar: 4,\n\t\tHorizontalMultiBar: 5,\n\t\tDiscreteBar: 6\n\t};\n\n\tApp.LineType = {\n\t\tWithDots: 0,\n\t\tWithoutDots: 1,\n\t\tUnjoinedIfMissing: 2,\n\t\tDashedIfMissing: 3\n\t}\n\n\t//export for iframe\n\twindow.$ = jQuery;\n\n\t//export\n\twindow.App = App;\n})();\n\n",";(function() {\n\t\"use strict\";\n\twindow.App = window.App || {};\n\tApp.Utils = App.Utils || {};\n\tApp.Utils.FormHelper = App.Utils.FormHelper || {};\n\t\n\tApp.Utils.mapData = function( rawData, transposed ) {\n\n\t\tvar data = [],\n\t\t\tdataById = [],\n\t\t\tcountryIndex = 1;\n\n\t\t//do we have entities in rows and times in columns?\t\n\t\tif( !transposed ) {\n\t\t\t//no, we have to switch rows and columns\n\t\t\trawData = App.Utils.transpose( rawData );\n\t\t}\n\t\t\n\t\t//extract time column\n\t\tvar timeArr = rawData.shift();\n\t\t//get rid of first item (label of time column) \n\t\ttimeArr.shift();\n\t\n\t\tfor( var i = 0, len = rawData.length; i < len; i++ ) {\n\n\t\t\tvar singleRow = rawData[ i ],\n\t\t\t\tcolName = singleRow.shift();\n\t\t\t\t\n\t\t\t//ommit rows with no colNmae\n\t\t\tif( colName ) {\n\t\t\t\tvar singleData = [];\n\t\t\t\t_.each( singleRow, function( value, i ) {\n\t\t\t\t\t//check we have value\n\t\t\t\t\tif( value !== \"\" ) {\n\t\t\t\t\t\tsingleData.push( { x: timeArr[i], y: ( !isNaN( value ) )? +value: value } );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\t//construct entity obj\n\t\t\t\tvar\tentityObj = {\n\t\t\t\t\tid: i,\n\t\t\t\t\tkey: colName,\n\t\t\t\t\tvalues: singleData\n\t\t\t\t};\n\t\t\t\tdata.push( entityObj );\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tApp.Utils.mapSingleVariantData = function( rawData, variableName ) {\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tvalues: App.Utils.mapData( rawData, true )\n\t\t};\n\t\treturn [variable];\n\n\t},\n\n\t/*App.Utils.mapMultiVariantData = function( rawData, entityName ) {\n\t\t\n\t\t//transform multivariant into standard format ( time, entity )\n\t\tvar variables = [],\n\t\t\ttransposed = rawData,//App.Utils.transpose( rawData ),\n\t\t\ttimeArr = transposed.shift();\n\n\t\t//get rid of first item (label of time column) \n\t\t//timeArr.shift();\n\t\t\n\t\t_.each( transposed, function( values, key, list ) {\n\n\t\t\t//get variable name from first cell of columns\n\t\t\tvar variableName = values.shift();\n\t\t\t//add entity name as first cell\n\t\t\tvalues.unshift( entityName );\n\t\t\t//construct array for mapping, need to deep copy timeArr\n\t\t\tvar localTimeArr = $.extend( true, [], timeArr);\n\t\t\tvar dataToMap = [ localTimeArr, values ];\n\t\t\t//construct object\n\t\t\tvar variable = {\n\t\t\t\tname: variableName,\n\t\t\t\tvalues: App.Utils.mapData( dataToMap, true )\n\t\t\t};\n\t\t\tvariables.push( variable );\n\n\t\t} );\n\n\t\treturn variables;\n\n\t},*/\n\n\tApp.Utils.mapMultiVariantData = function( rawData ) {\n\t\t\n\t\tvar variables = [],\n\t\t\ttransposed = rawData,\n\t\t\theaderArr = transposed.shift();\n\n\t\t//get rid of entity and year column name\n\t\theaderArr = headerArr.slice( 2 );\n\n\t\tvar varPerRowData = App.Utils.transpose( transposed ),\n\t\t\tentitiesRow = varPerRowData.shift(),\n\t\t\ttimesRow = varPerRowData.shift();\n\n\t\t_.each( varPerRowData, function( values, varIndex ) {\n\t\t\t\n\t\t\tvar entities = {};\n\t\t\t//iterate through all values for given variable\n\t\t\t_.each( values, function( value, key ) {\n\t\t\t\tvar entity = entitiesRow[ key ],\n\t\t\t\t\ttime = timesRow[ key ];\n\t\t\t\tif( entity && time ) {\n\t\t\t\t\t//do have already entity defined?\n\t\t\t\t\tif( !entities[ entity ] ) {\n\t\t\t\t\t\tentities[ entity ] = {\n\t\t\t\t\t\t\tid: key,\n\t\t\t\t\t\t\tkey: entity,\n\t\t\t\t\t\t\tvalues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tentities[ entity ].values.push( { x: time, y: ( !isNaN( value ) )? +value: value } );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t//have data for all entities, just convert them to array\n\t\t\tvar varValues = _.map( entities, function( value ) { return value; } );\n\t\t\t\n\t\t\tvar variable = {\n\t\t\t\tname: headerArr[ varIndex ],\n\t\t\t\tvalues: varValues\n\t\t\t};\n\t\t\tvariables.push( variable );\n\n\t\t} );\n\n\t\treturn variables;\n\t},\n\n\tApp.Utils.transpose = function( arr ) {\n\t\tvar keys = _.keys( arr[0] );\n\t\treturn _.map( keys, function (c) {\n\t\t\treturn _.map( arr, function( r ) {\n\t\t\t\treturn r[c];\n\t\t\t} );\n\t\t});\n\t},\n\n\tApp.Utils.transform = function() {\n\n\t\tconsole.log( \"app.utils.transform\" );\n\n\t},\n\n\tApp.Utils.encodeSvgToPng = function( html ) {\n\n\t\tconsole.log( html );\n\t\tvar imgSrc = \"data:image/svg+xml;base64,\" + btoa(html),\n\t\t\timg = \"<img src='\" + imgSrc + \"'>\"; \n\t\t\n\t\t//d3.select( \"#svgdataurl\" ).html( img );\n\n\t\t$( \".chart-wrapper-inner\" ).html( img );\n\n\t\t/*var canvas = document.querySelector( \"canvas\" ),\n\t\t\tcontext = canvas.getContext( \"2d\" );\n\n\t\tvar image = new Image;\n\t\timage.src = imgsrc;\n\t\timage.onload = function() {\n\t\t\tcontext.drawImage(image, 0, 0);\n\t\t\tvar canvasData = canvas.toDataURL( \"image/png\" );\n\t\t\tvar pngImg = '<img src=\"' + canvasData + '\">'; \n\t\t\td3.select(\"#pngdataurl\").html(pngimg);\n\n\t\t\tvar a = document.createElement(\"a\");\n\t\t\ta.download = \"sample.png\";\n\t\t\ta.href = canvasdata;\n\t\t\ta.click();\n\t\t};*/\n\n\n\t};\n\n\t/**\n\t*\tTIME RELATED FUNCTIONS\n\t**/\n\n\tApp.Utils.nth = function ( d ) {\n\t\t//conver to number just in case\n\t\td = +d;\n\t\tif( d > 3 && d < 21 ) return 'th'; // thanks kennebec\n\t\tswitch( d % 10 ) {\n\t\t\tcase 1:  return \"st\";\n\t\t\tcase 2:  return \"nd\";\n\t\t\tcase 3:  return \"rd\";\n\t\t\tdefault: return \"th\";\n\t\t}\n\t}\n\n\tApp.Utils.centuryString = function ( d ) {\n\t\t//conver to number just in case\n\t\td = +d;\n\t\t\n\t\tvar centuryNum = Math.floor(d / 100) + 1,\n\t\t\tcenturyString = centuryNum.toString(),\n\t\t\tnth = App.Utils.nth( centuryString );\n\n\t\treturn centuryString + nth + \" century\";\n\t}\n\n\tApp.Utils.addZeros = function ( value ) {\n\n\t\tvalue = value.toString();\n\t\tif( value.length < 4 ) {\n\t\t\t//insert missing zeros\n\t\t\tvar valueLen = value.length;\n\t\t\tfor( var y = 0; y < 4 - valueLen; y++ ) {\n\t\t\t\tvalue = \"0\" + value;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t\t\n\t}\n\n\tApp.Utils.roundTime = function( momentTime ) {\n\n\t\tif( typeof momentTime.format === \"function\" ) {\n\t\t\t//use short format mysql expects - http://stackoverflow.com/questions/10539154/insert-into-db-datetime-string\n\t\t\treturn momentTime.format( \"YYYY-MM-DD\" );\n\t\t}\n\t\treturn momentTime;\n\n\t}\n\n\t/** \n\t* FORM HELPER\n\t**/\n\tApp.Utils.FormHelper.validate = function( $form ) {\n\t\t\n\t\tvar missingErrorLabel = \"Please enter value.\",\n\t\t\temailErrorLabel =  \"Please enter valide email.\",\n\t\t\tnumberErrorLabel = \"Please ente valid number.\"; \n\n\t\tvar invalidInputs = [];\n\t\t\n\t\t//gather all fields requiring validation\n\t\tvar $requiredInputs = $form.find( \".required\" );\n\t\tif( $requiredInputs.length ) {\n\n\t\t\t$.each( $requiredInputs, function( i, v ) {\n\n\t\t\t\tvar $input = $( this );\n\t\t\t\t\n\t\t\t\t//filter only visible\n\t\t\t\tif( !$input.is( \":visible\" ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//check for empty\n\t\t\t\tvar inputValid = App.Utils.FormHelper.validateRequiredField( $input );\n\t\t\t\tif( !inputValid ) {\n\t\t\t\t\n\t\t\t\t\tApp.Utils.FormHelper.addError( $input, missingErrorLabel );\n\t\t\t\t\tinvalidInputs.push( $input );\n\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tApp.Utils.FormHelper.removeError( $input );\n\n\t\t\t\t\t//check for digit\n\t\t\t\t\tif( $input.hasClass( \"required-number\" ) ) {\n\t\t\t\t\t\tinputValid = App.Utils.FormHelper.validateNumberField( $input );\n\t\t\t\t\t\tif( !inputValid ) {\n\t\t\t\t\t\t\tApp.Utils.FormHelper.addError( $input, numberErrorLabel );\n\t\t\t\t\t\t\tinvalidInputs.push( $input );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tApp.Utils.FormHelper.removeError( $input );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//check for mail\n\t\t\t\t\tif( $input.hasClass( \"required-mail\" ) ) {\n\t\t\t\t\t\tinputValid = FormHelper.validateEmailField( $input );\n\t\t\t\t\t\tif( !inputValid ) {\n\t\t\t\t\t\t\tApp.Utils.FormHelper.addError( $input, emailErrorLabel );\n\t\t\t\t\t\t\tinvalidInputs.push( $input );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tApp.Utils.FormHelper.removeError( $input );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//check for checkbox\n\t\t\t\t\tif( $input.hasClass( \"required-checkbox\" ) ) {\n\n\t\t\t\t\t\tinputValid = FormHelper.validateCheckbox( $input );\n\t\t\t\t\t\tif( !inputValid ) {\n\t\t\t\t\t\t\tApp.Utils.FormHelper.addError( $input, missingErrorLabel );\n\t\t\t\t\t\t\tinvalidInputs.push( $input );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tApp.Utils.FormHelper.removeError( $input );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\n\t\t\t} );\n\n\t\t}\n\n\n\t\tif( invalidInputs.length ) {\n\n\t\t\t//take first element and scroll to it\n\t\t\tvar $firstInvalidInput = invalidInputs[0];\n\t\t\t$('html, body').animate( {\n\t\t\t\tscrollTop: $firstInvalidInput.offset().top - 25\n\t\t\t}, 250);\n\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\n\t\treturn true; \n\n\t};\n\n\tApp.Utils.FormHelper.validateRequiredField = function( $input ) {\n\n\t\treturn ( $input.val() === \"\" ) ? false : true;\n\n\t};\n\n\tApp.Utils.FormHelper.validateEmailField = function( $input ) {\n\n\t\tvar email = $input.val();\n\t\tvar regex = /^([\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,6})?$/;\n\t\treturn regex.test( email );\n\n\t};\n\n\tApp.Utils.FormHelper.validateNumberField = function( $input ) {\n\n\t\treturn ( isNaN( $input.val() ) ) ? false : true;\n\n\t};\n\n\tApp.Utils.FormHelper.validateCheckbox = function( $input ) {\n\n\t\treturn ( $input.is(':checked') ) ? true : false;\n\n\t};\n\n\n\tApp.Utils.FormHelper.addError = function( $el, $msg ) {\n\n\t\tif( $el ) {\n\t\t\tif( !$el.hasClass( \"error\" ) ) {\n\t\t\t\t$el.addClass( \"error\" );\n\t\t\t\t$el.before( \"<p class='error-label'>\" + $msg + \"</p>\" );\n\t\t\t}\n\t\t}\n\n\t};\n\n\tApp.Utils.FormHelper.removeError = function( $el ) {\n\n\t\tif( $el ) {\n\t\t\t$el.removeClass( \"error\" );\n\t\t\tvar $parent = $el.parent();\n\t\t\tvar $errorLabel = $parent.find( \".error-label\" );\n\t\t\tif( $errorLabel.length ) {\n\t\t\t\t$errorLabel.remove();\n\t\t\t}\n\t\t}\n\t\t\n\t};\n\n\tApp.Utils.wrap = function( $el, width ) {\n\t\t\n\t\t//get rid of potential tspans and get pure content (including hyperlinks)\n\t\tvar textContent = \"\",\n\t\t\t$tspans = $el.find( \"tspan\" );\n\t\tif( $tspans.length ) {\n\t\t\t$.each( $tspans, function( i, v ) {\n\t\t\t\tif( i > 0 ) {\n\t\t\t\t\ttextContent += \" \";\n\t\t\t\t}\n\t\t\t\ttextContent += $(v).text();\n\t\t\t} );\t\n\t\t} else {\n\t\t\t//element has no tspans, possibly first run\n\t\t\ttextContent = $el.text();\n\t\t}\n\t\t\n\t\t//append to element\n\t\tif( textContent ) {\n\t\t\t$el.text( textContent );\n\t\t}\n\t\t\n\t\tvar isVisible = $el.is( \":visible\" );\n\n\t\t//make el visible for the time of being computed, otherwise getComputedTextLength returns 0\n\t\t$el.show();\n\n\t\tvar text = d3.select( $el.selector );\n\t\ttext.each( function() {\n\t\t\tvar text = d3.select(this),\n\t\t\t\tstring = $.trim(text.text()),\n\t\t\t\tregex = /\\s+/,\n\t\t\t\twords = string.split(regex).reverse();\n\n\t\t\tvar word,\n\t\t\t\tline = [],\n\t\t\t\tlineNumber = 0,\n\t\t\t\tlineHeight = 1.4, // ems\n\t\t\t\ty = text.attr(\"y\"),\n\t\t\t\tdy = parseFloat(text.attr(\"dy\")),\n\t\t\t\ttspan = text.text(null).append(\"tspan\").attr(\"x\", 0).attr(\"y\", y).attr(\"dy\", dy + \"em\");\n\t\t\t\n\t\t\twhile( word = words.pop() ) {\n\t\t\t\tline.push(word);\n\t\t\t\ttspan.html(line.join(\" \"));\n\t\t\t\tif( tspan.node().getComputedTextLength() > width ) {\n\t\t\t\t\tline.pop();\n\t\t\t\t\ttspan.text(line.join(\" \"));\n\t\t\t\t\tline = [word];\n\t\t\t\t\ttspan = text.append(\"tspan\").attr(\"x\", 0).attr(\"y\", y).attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\").text(word);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} );\n\n\t\t//cache element height while it's still visible\n\t\tvar elBoundingBox = $el.get(0).getBoundingClientRect(),\n\t\t\telHeight = elBoundingBox.bottom - elBoundingBox.top;\n\n\t\t//done with the dimension computations, hide element again, if it was invisible\n\t\tif( !isVisible ) {\n\t\t\t$el.hide();\t\n\t\t}\n\n\t\t//in some user cases, can be useful to return height\n\t\treturn elHeight;\n\n\t};\n\n\t/**\n\t* Convert a string to HTML entities\n\t*/\n\tApp.Utils.toHtmlEntities = function(string) {\n\t\treturn string.replace(/./gm, function(s) {\n\t\t\treturn \"&#\" + s.charCodeAt(0) + \";\";\n\t\t});\n\t};\n\n\t/**\n\t * Create string from HTML entities\n\t */\n\tApp.Utils.fromHtmlEntities = function(string) {\n\t\treturn (string+\"\").replace(/&#\\d+;/gm,function(s) {\n\t\t\treturn String.fromCharCode(s.match(/\\d+/gm)[0]);\n\t\t})\n\t};\n\n\tApp.Utils.getRandomColor = function () {\n\t\tvar letters = '0123456789ABCDEF'.split('');\n\t\tvar color = '#';\n\t\tfor (var i = 0; i < 6; i++ ) {\n\t\t\tcolor += letters[Math.floor(Math.random() * 16)];\n\t\t}\n\t\treturn color;\n\t};\n\n\tApp.Utils.getPropertyByVariableId = function( model, variableId ) {\n\n\t\tif( model && model.get( \"chart-dimensions\" ) ) {\n\n\t\t\tvar chartDimensionsString = model.get( \"chart-dimensions\" ),\n\t\t\t\tchartDimensions = $.parseJSON( chartDimensionsString ),\n\t\t\t\tdimension = _.where( chartDimensions, { \"variableId\": variableId } );\n\t\t\tif( dimension && dimension.length ) {\n\t\t\t\treturn dimension[0].property;\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\t\t\n\t};\n\n\tApp.Utils.formatTimeLabel = function( type, d, xAxisPrefix, xAxisSuffix, format ) {\n\t\t//depending on type format label\n\t\tvar label;\n\t\tswitch( type ) {\n\t\t\t\n\t\t\tcase \"Decade\":\n\t\t\t\t\n\t\t\t\tvar decadeString = d.toString();\n\t\t\t\tdecadeString = decadeString.substring( 0, decadeString.length - 1);\n\t\t\t\tdecadeString = decadeString + \"0s\";\n\t\t\t\tlabel = decadeString;\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"Quarter Century\":\n\t\t\t\t\n\t\t\t\tvar quarterString = \"\",\n\t\t\t\t\tquarter = d % 100;\n\t\t\t\t\n\t\t\t\tif( quarter < 25 ) {\n\t\t\t\t\tquarterString = \"1st quarter of the\";\n\t\t\t\t} else if( quarter < 50 ) {\n\t\t\t\t\tquarterString = \"half of the\";\n\t\t\t\t} else if( quarter < 75 ) {\n\t\t\t\t\tquarterString = \"3rd quarter of the\";\n\t\t\t\t} else {\n\t\t\t\t\tquarterString = \"4th quarter of the\";\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tvar centuryString = App.Utils.centuryString( d );\n\n\t\t\t\tlabel = quarterString + \" \" + centuryString;\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"Half Century\":\n\t\t\t\t\n\t\t\t\tvar halfString = \"\",\n\t\t\t\t\thalf = d % 100;\n\t\t\t\t\n\t\t\t\tif( half < 50 ) {\n\t\t\t\t\thalfString = \"1st half of the\";\n\t\t\t\t} else {\n\t\t\t\t\thalfString = \"2nd half of the\";\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tvar centuryString = App.Utils.centuryString( d );\n\n\t\t\t\tlabel = halfString + \" \" + centuryString;\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"Century\":\n\t\t\t\t\n\t\t\t\tlabel = App.Utils.centuryString( d );\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tlabel = App.Utils.formatValue( d, format );\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t\treturn xAxisPrefix + label + xAxisSuffix;\n\t};\n\n\tApp.Utils.inlineCssStyle = function( rules ) {\n\t\t//http://devintorr.es/blog/2010/05/26/turn-css-rules-into-inline-style-attributes-using-jquery/\n\t\tfor (var idx = 0, len = rules.length; idx < len; idx++) {\n\t\t\t//in Safari - Error: Syntax error, unrecognized expression: input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button]\n\t\t\ttry {\n\t\t\t\t$(rules[idx].selectorText).each(function (i, elem) {\n\t\t\t\t\telem.style.cssText += rules[idx].style.cssText;\n\t\t\t\t});\t\n\t\t\t} catch(err) {}\n\t\t}\n\n\t\t$(\"style\").remove();\n\t};\n\n\tApp.Utils.checkValidDimensions = function( dimensions, chartType ) {\n\t\t\t\n\t\tvar validDimensions = false,\n\t\t\txDimension, yDimension;\n\t\t\n\t\tswitch( chartType ) {\n\t\t\tcase \"1\":\n\t\t\tcase \"4\":\n\t\t\tcase \"5\":\n\t\t\tcase \"6\":\n\t\t\t\t//check that dimensions have y property\n\t\t\t\tyDimension = _.find( dimensions, function( dimension ) {\n\t\t\t\t\treturn dimension.property === \"y\";\n\t\t\t\t} );\n\t\t\t\tif( yDimension ) {\n\t\t\t\t\tvalidDimensions = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"2\":\n\t\t\t\t//check that dimensions have x property\n\t\t\t\txDimension = _.find( dimensions, function( dimension ) {\n\t\t\t\t\treturn dimension.property === \"x\";\n\t\t\t\t} );\n\t\t\t\tyDimension = _.find( dimensions, function( dimension ) {\n\t\t\t\t\treturn dimension.property === \"y\";\n\t\t\t\t} );\n\t\t\t\tif( xDimension && yDimension ) {\n\t\t\t\t\tvalidDimensions = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"3\":\n\t\t\t\t//check that dimensions have y property\n\t\t\t\tyDimension = _.find( dimensions, function( dimension ) {\n\t\t\t\t\treturn dimension.property === \"y\";\n\t\t\t\t} );\n\t\t\t\tif( yDimension ) {\n\t\t\t\t\tvalidDimensions = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\treturn validDimensions;\n\n\t};\n\n\tApp.Utils.formatValue = function( value, format ) {\n\t\t//make sure we do this on number\n\t\tif( value && !isNaN( value ) ) {\n\t\t\tif( format && !isNaN( format ) ) {\n\t\t\t\tvar fixed = Math.min( 20, parseInt( format, 10 ) );\n\t\t\t\tvalue = value.toFixed( fixed );\n\t\t\t} else {\n\t\t\t\t//no format \n\t\t\t\tvalue = value.toString();\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t};\n})();",";(function() {\n\t\"use strict\";\n\towid.namespace(\"App.Models.ChartModel\");\n\n\tApp.Models.ChartModel = Backbone.Model.extend( {\n\n\t\t//urlRoot: Global.rootUrl + '/charts/',\n\t\t//urlRoot: Global.rootUrl + '/data/config/',\n\t\turl: function(id) {\n\t\t\tid = id || this.id;\n\t\t\tif( $(\"#form-view\").length ) {\n\t\t\t\tif( id ) {\n\t\t\t\t\t//editing existing\n\t\t\t\t\treturn Global.rootUrl + \"/charts/\" + id;\n\t\t\t\t} else {\n\t\t\t\t\t//saving new\n\t\t\t\t\treturn Global.rootUrl + \"/charts\";\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// Pass any query parameters on to config\n\t\t\t\treturn Global.rootUrl + \"/data/config/\" + id + window.location.search;\n\t\t\t}\n\t\t},\n\n\t\tdefaults: {\n\t\t\t\"chart-name\": \"\",\n\t\t\t\"chart-slug\": \"\",\n\t\t\t\"chart-notes\": \"\",\n\t\t\t// A range of form e.g. [0, 2015] with null meaning \"all of it\"\n\t\t\t\"chart-time\": null,\n\t\t\t\"cache\": true,\n\t\t\t\"selected-countries\": [], // e.g. [{id: \"1\", name: \"United Kingdom\"}]\n\t\t\t\"tabs\": [ \"chart\", \"data\", \"sources\" ],\n\t\t\t\"default-tab\": \"chart\",\n\t\t\t\"line-type\": 0,\n\t\t\t\"line-tolerance\": 1,\n\t\t\t\"chart-description\": \"\",\n\t\t\t\"chart-dimensions\": [],\n\t\t\t\"variables\": [],\n\t\t\t\"y-axis\": {\"axis-label-distance\":\"-10\"},\n\t\t\t\"x-axis\": {},\n\t\t\t\"margins\": { top: 10, left: 60, bottom: 10, right: 10 },\n\t\t\t\"units\": \"\",\n\t\t\t\"logo\": \"uploads/26538.png\",\n\t\t\t\"second-logo\": null,\n\t\t\t\"iframe-width\": \"100%\",\n\t\t\t\"iframe-height\": \"660px\",\n\t\t\t\"hide-legend\": false,\n\t\t\t\"group-by-variables\": false,\n\t\t\t\"add-country-mode\": \"add-country\",\n\t\t\t\"x-axis-scale-selector\": false,\n\t\t\t\"y-axis-scale-selector\": false,\n\t\t\t\"map-config\": {\n\t\t\t\t\"variableId\": -1,\n\t\t\t\t\"targetYear\": 1980,\n\t\t\t\t\"targetYearMode\": \"normal\",\n\t\t\t\t\"defaultYear\": 1980,\n\t\t\t\t\"mode\": \"specific\",\n\t\t\t\t\"timeTolerance\": 1,\n\t\t\t\t\"minYear\": 1980,\n\t\t\t\t\"maxYear\": 2000,\n\t\t\t\t// timeRanges is a collection of objects specifying year ranges e.g.\n\t\t\t\t//\n\t\t\t\t// [\n\t\t\t\t//   { year: 1980 },\n\t\t\t\t//   { startYear: 1990, endYear: 2000, interval: 5 },\n\t\t\t\t//   { startYear: 2005, endYear: 2008 }\n\t\t\t\t// ]\n\t\t\t\t//\n\t\t\t\t// Produces the years: 1980, 1990, 1995, 2000, 2005, 2007, 2008\n\t\t\t\t\"timeRanges\": [],\n\t\t\t\t\"timelineMode\": \"timeline\",\n\t\t\t\t\"colorSchemeName\": \"BuGn\",\n\t\t\t\t\"colorSchemeValues\": false,\n\t\t\t\t\"colorSchemeLabels\": [],\n\t\t\t\t\"colorSchemeValuesAutomatic\": true,\n\t\t\t\t\"colorSchemeInterval\": 5,\n\t\t\t\t// Whether to reverse the color scheme on output\n\t\t\t\t\"colorSchemeInvert\": false,\n\t\t\t\t\"colorSchemeMinValue\": null,\n\t\t\t\t// e.g. [\"#000\", \"#c00\", \"#0c0\", \"#00c\", \"#c0c\"]\n\t\t\t\t\"customColorScheme\": [],\n\t\t\t\t\"isColorblind\": false,\n\t\t\t\t\"projection\": \"World\",\n\t\t\t\t\"defaultProjection\": \"World\",\n\t\t\t\t\"legendDescription\": \"\",\n\t\t\t\t\"legendStepSize\": 20,\n\t\t\t\t\"legendOrientation\": \"portrait\",\n\t\t\t}\n\t\t},\n\n\t\tinitialize: function() {\n\t\t\tthis.on( \"sync\", this.onSync, this );\n\t\t\t$(document).trigger(\"chart-model\");\n\t\t},\n\n\t\tonSync: function() {\n\t\t\tif( this.get( \"chart-type\" ) == App.ChartType.ScatterPlot ) {\n\t\t\t\t//make sure for scatter plot, we have color set as continents\n\t\t\t\tvar chartDimensions = $.parseJSON( this.get( \"chart-dimensions\" ) );\n\t\t\t\tif( !_.findWhere( chartDimensions, { \"property\": \"color\" } ) ) {\n\t\t\t\t\t//this is where we add color property\n\t\t\t\t\tvar colorPropObj = { \"variableId\":\"123\",\"property\":\"color\",\"unit\":\"\",\"name\":\"Color\",\"period\":\"single\",\"mode\":\"specific\",\"targetYear\":\"2000\",\"tolerance\":\"5\",\"maximumAge\":\"5\"};\n\t\t\t\t\tchartDimensions.push( colorPropObj );\n\t\t\t\t\tvar charDimensionsString = JSON.stringify( chartDimensions );\n\t\t\t\t\tthis.set( \"chart-dimensions\", charDimensionsString );\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t},\n\n\t\taddSelectedCountry: function( country ) {\n\t\t\tvar selectedCountries = this.get( \"selected-countries\" );\n\n\t\t\t//make sure the selected contry is not there \n\t\t\tif( !_.findWhere( selectedCountries, { id: country.id } ) ) {\n\t\t\t\tselectedCountries.push( country );\n\t\t\t\t//selectedCountries[ country.id ] = country;\n\t\t\t\tthis.trigger( \"change:selected-countries\" );\n\t\t\t\tthis.trigger( \"change\" );\n\t\t\t}\n\t\t},\n\n\t\tupdateSelectedCountry: function( countryId, color ) {\n\t\t\tvar country = this.findCountryById( countryId );\n\t\t\tif( country ) {\n\t\t\t\tcountry.color = color;\n\t\t\t\tthis.trigger( \"change:selected-countries\" );\n\t\t\t\tthis.trigger( \"change\" );\n\t\t\t}\n\t\t},\n\n\t\tremoveSelectedCountry: function(entityName) {\n\t\t\tvar selectedCountries = this.get(\"selected-countries\");\n\t\t\tvar entity = _.findWhere(selectedCountries, { name: entityName });\n\t\t\tif (!entity) return;\n\n\t\t\tselectedCountries = _.filter(selectedCountries, function(entity) {\n\t\t\t\treturn entity.name != entityName;\n\t\t\t});\n\n\t\t\tthis.set(\"selected-countries\", selectedCountries);\n\t\t},\n\n\t\treplaceSelectedCountry: function( country ) {\n\t\t\tif( country ) {\n\t\t\t\tthis.set( \"selected-countries\", [ country ] );\n\t\t\t}\n\t\t},\n\n\t\tfindCountryById: function( countryId ) {\n\t\t\tvar selectedCountries = this.get( \"selected-countries\" ),\n\t\t\t\tcountry = _.findWhere(selectedCountries, { id: countryId });\n\t\t\treturn country;\n\t\t},\n\n\t\tsetAxisConfig: function( axisName, prop, value ) {\n\t\t\tif( $.isArray( this.get( \"y-axis\" ) ) ) {\n\t\t\t\t//we got empty array from db, convert to object\n\t\t\t\tthis.set( \"y-axis\", {} );\n\t\t\t}\n\t\t\tif( $.isArray( this.get( \"x-axis\" ) ) ) {\n\t\t\t\t//we got empty array from db, convert to object\n\t\t\t\tthis.set( \"x-axis\", {} );\n\t\t\t}\n\n\t\t\tvar axis = this.get( axisName );\n\t\t\tif( axis ) {\n\t\t\t\taxis[ prop ] = value;\n\t\t\t}\n\t\t\tthis.trigger( \"change\" );\n\t\t},\n\n\t\tgetAxisConfig: function(axisName, prop) {\n\t\t\tvar axis = this.get(axisName);\n\t\t\tif (axis) return axis[prop];\n\t\t},\n\n\t\tupdateVariables: function( newVar ) {\n\t\t\t//copy array\n\t\t\tvar variables = this.get( \"variables\" ).slice(),\n\t\t\t\tvarInArr = _.find( variables, function( v ){ return v.id == newVar.id; } );\n\n\t\t\tif( !varInArr ) {\n\t\t\t\tvariables.push( newVar );\n\t\t\t\tthis.set( \"variables\", variables );\n\t\t\t}\n\t\t},\n\n\t\tremoveVariable: function( varIdToRemove ) {\n\t\t\t//copy array\n\t\t\tvar variables = this.get( \"variables\" ).slice(),\n\t\t\t\tvarInArr = _.find( variables, function( v ){ return v.id == newVar.id; } );\n\n\t\t\tif( !varInArr ) {\n\t\t\t\tvariables.push( newVar );\n\t\t\t\tthis.set( \"variables\", variables );\n\t\t\t}\n\t\t},\n\n\t\tupdateMapConfig: function(propName, propValue, silent, eventName) {\n\t\t\tvar mapConfig = this.get(\"map-config\");\n\n\t\t\tif (!_.has(this.defaults[\"map-config\"], propName))\n\t\t\t\tconsole.warn(\"No defined default for map config property '\" + propName + \"'\");\n\n\t\t\t//if changing colorschem interval and custom colorscheme is used, update it\n\t\t\tif (propName === \"colorSchemeInterval\" && mapConfig.colorSchemeName === \"custom\")\n\t\t\t\tmapConfig.customColorScheme = mapConfig.customColorScheme.slice( 0, propValue );\n\n\t\t\tmapConfig[propName] = propValue;\n\n\t\t\tif (!silent)\n\t\t\t\tthis.trigger(eventName || \"change\");\n\t\t}\n\t} );\n\n})();",";(function() {\t\t\n\t\"use strict\";\n\n\twindow.App = window.App || {};\n\tApp.Models = App.Models || {};\n\n\t/**\n\t * This model handles the mass retrieval of data values associated with one\n\t * or more variables, and is responsible for transforming the raw data into\n\t * formats appropriate for use by the charts or other frontend systems.\n\t **/\n\tApp.Models.ChartDataModel = Backbone.Model.extend( {\n\t\tdefaults: {},\n\n\t\tinitialize: function () {\n\t\t\tApp.ChartModel.on(\"change:chart-dimensions\", this.update, this);\n\t\t\tthis.update();\n\t\t},\n\n\t\tupdate: function() \t{\t\n\t\t\tif (_.isEmpty(App.ChartModel.get(\"chart-dimensions\"))) return;\n\n\t\t\tif (this.dataRequest) {\n\t\t\t\tthis.dataRequest.abort();\n\t\t\t\tthis.dataRequest = null;\n\t\t\t}\n\n\t\t\tthis.dimensions = JSON.parse(App.ChartModel.get(\"chart-dimensions\"));\n\t\t\tvar variableIds = _.map(this.dimensions, function(dim) { return dim.variableId; });\n\t\t\tif (_.isEmpty(variableIds)) {\n\t\t\t\tthis.clear();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.isReady = false;\n\t\t\tthis.set(\"variableData\", null, { silent: true });\n\t\t\t// There's no cache tag in the editor\n\t\t\tvar cacheTag = App.ChartModel.get(\"variableCacheTag\");\n\t\t\tif (cacheTag)\n\t\t\t\tthis.dataRequest = $.get(Global.rootUrl + \"/data/variables/\" + variableIds.join(\"+\") + \"?v=\" + App.ChartModel.get(\"variableCacheTag\"));\n\t\t\telse\n\t\t\t\tthis.dataRequest = $.get(Global.rootUrl + \"/data/variables/\" + variableIds.join(\"+\"));\n\t\t\tthis.dataRequest.done(function(rawData) {\n\t\t\t\tthis.dataRequest = null;\n\t\t\t\tthis.receiveData(rawData);\n\t\t\t}.bind(this));\n\t\t},\n\n\t\treceiveData: function(rawData) {\n\t\t\tvar variableData = {};\n\n\t\t\tvar lines = rawData.split(\"\\r\\n\");\n\n\t\t\tlines.forEach(function(line, i) {\n\t\t\t\tif (i == 0) { // First line contains the basic variable metadata \n\t\t\t\t\tvariableData = JSON.parse(line);\n\t\t\t\t} else if (i == lines.length-1) { // Final line is entity id => name mapping\n\t\t\t\t\tvariableData.entityKey = JSON.parse(line);\n\t\t\t\t} else {\n\t\t\t\t\tvar points = line.split(\";\");\n\t\t\t\t\tvar variable;\n\t\t\t\t\tpoints.forEach(function(d, j) {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tvariable = variableData.variables[d];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar spl = d.split(\",\");\n\t\t\t\t\t\t\tvariable.years.push(spl[0]);\n\t\t\t\t\t\t\tvariable.entities.push(spl[1]);\n\t\t\t\t\t\t\tvariable.values.push(spl[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// We calculate some basic metadata that is likely to be useful to everyone\n\t\t\tvar startYears = _.map(variableData.variables, function(v) { return _.first(v.years); });\n\t\t\tvar endYears = _.map(variableData.variables, function(v) { return _.last(v.years); });\n\t\t\tvar minYear = _.min(startYears);\n\t\t\tvar maxYear = _.max(endYears);\n\n\t\t\tvar availableEntities = [];\n\t\t\t_.each(variableData.entityKey, function(entity, id) {\n\t\t\t\tavailableEntities.push(_.extend({}, entity, { \"id\": +id }));\n\t\t\t});\n\n\t\t\twindow.variableData = variableData;\n\t\t\tthis.isReady = true;\t\n\t\t\tthis.set({ variableData: variableData, minYear: minYear, maxYear: maxYear, availableEntities: availableEntities });\n\t\t},\n\n\t\tready: function(callback) {\n\t\t\tvar variableData = this.get(\"variableData\");\n\t\t\tif (!variableData) {\n\t\t\t\tthis.once(\"change:variableData\", function() {\n\t\t\t\t\tcallback(this.get(\"variableData\"));\n\t\t\t\t}.bind(this));\n\t\t\t} else {\n\t\t\t\tcallback(variableData);\n\t\t\t}\n\t\t},\n\n\t\tgetSelectedCountriesById: function() {\n\t\t\tvar variableData = this.get(\"variableData\"),\n\t\t\t\tselectedCountries = App.ChartModel.get(\"selected-countries\"),\t\t\t\t\n\t\t\t\tchartType = App.ChartModel.get(\"chart-type\"),\n\t\t\t\tselectedCountriesById = {};\n\n\t\t\tif (chartType != App.ChartType.ScatterPlot && _.isEmpty(selectedCountries)) {\n\t\t\t\tvar random = _.sample(_.uniq(Object.keys(variableData.entityKey)), 3);\n\t\t\t\tselectedCountries = [];\n\t\t\t\t_.each(random, function(entityId) {\n\t\t\t\t\tselectedCountries.push({\n\t\t\t\t\t\tid: entityId,\n\t\t\t\t\t\tname: variableData.entityKey[entityId].name\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tApp.ChartModel.set(\"selected-countries\", selectedCountries);\n\t\t\t}\n\n\t\t\t_.each(selectedCountries, function(entity) {\n\t\t\t\tselectedCountriesById[entity.id] = entity;\n\t\t\t});\n\n\t\t\treturn selectedCountriesById;\n\t\t},\n\n\t\ttransformDataForLineChart: function() {\n\t\t\tvar dimensions = _.clone(this.dimensions).reverse(), // Keep them stacked in the same visual order as editor\n\t\t\t\tvariableData = this.get('variableData'),\n\t\t\t\tvariables = variableData.variables,\n\t\t\t\tentityKey = variableData.entityKey,\n\t\t\t\tselectedCountriesById = this.getSelectedCountriesById(),\n\t\t\t\tyAxis = App.ChartModel.get(\"y-axis\"),\n\t\t\t\tlocalData = [],\n\t\t\t\thasManyVariables = _.size(variables) > 1,\n\t\t\t\thasManyEntities = _.size(selectedCountriesById) > 1,\n\t\t\t\tminTransformedYear = Infinity,\n\t\t\t\tmaxTransformedYear = -Infinity;\n\n\t\t\t_.each(dimensions, function(dimension) {\n\t\t\t\tvar variable = variables[dimension.variableId],\n\t\t\t\t\tvariableName = dimension.displayName || variable.name,\n\t\t\t\t\tseriesByEntity = {};\n\n\t\t\t\tfor (var i = 0; i < variable.years.length; i++) {\n\t\t\t\t\tvar year = parseInt(variable.years[i]),\n\t\t\t\t\t\tvalue = parseFloat(variable.values[i]),\n\t\t\t\t\t\tentityId = variable.entities[i],\n\t\t\t\t\t\tentity = selectedCountriesById[entityId],\n\t\t\t\t\t\tseries = seriesByEntity[entityId];\n\n\t\t\t\t\t// Not a selected entity, don't add any data for it\n\t\t\t\t\tif (!entity) continue;\n\t\t\t\t\t// It's possible we may be missing data for this year/entity combination\n\t\t\t\t\t// e.g. http://ourworldindata.org/grapher/view/101\n\t\t\t\t\tif (isNaN(value)) continue;\n\t\t\t\t\t// Values <= 0 break d3 log scales horribly\n\t\t\t\t\tif (yAxis['axis-scale'] === 'log' && value <= 0) continue;\n\n\t\t\t\t\tif (!series) {\n\t\t\t\t\t\tvar key = entityKey[entityId].name,\n\t\t\t\t\t\t\tid = entityId;\n\t\t\t\t\t\t// If there are multiple variables per entity, we disambiguate the legend\n\t\t\t\t\t\tif (hasManyVariables) {\n\t\t\t\t\t\t\tid += \"-\" + variable.id;\n\n\t\t\t\t\t\t\tif (!hasManyEntities) {\n\t\t\t\t\t\t\t\tkey = variableName;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tkey += \" - \" + variableName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseries = {\n\t\t\t\t\t\t\tvalues: [],\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tentityName: entityKey[entityId].name,\n\t\t\t\t\t\t\tid: id\n\t\t\t\t\t\t};\n\t\t\t\t\t\tseriesByEntity[entityId] = series;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar prevValue = series.values[series.values.length-1];\n\t\t\t\t\tif (prevValue)\n\t\t\t\t\t\tprevValue.gapYearsToNext = year-prevValue.x;\n\t\t\t\t\tseries.values.push({ x: year, y: value, time: year });\n\t\t\t\t\tminTransformedYear = Math.min(minTransformedYear, year);\n\t\t\t\t\tmaxTransformedYear = Math.max(maxTransformedYear, year);\n\t\t\t\t}\n\n\t\t\t\t_.each(seriesByEntity, function(v, k) {\n\t\t\t\t\tlocalData.push(v);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthis.minTransformedYear = minTransformedYear;\n\t\t\tthis.maxTransformedYear = maxTransformedYear;\n\t\t\treturn localData;\n\t\t},\n\n\t\t// Ensures that every series has a value entry for every year in the data\n\t\t// Even if that value is just 0\n\t\t// Stacked area charts with incomplete data will fail to render otherwise\n\t\tzeroPadData: function(localData) {\n\t\t\tvar allYears = {};\t\t\t\n\t\t\tvar yearsForSeries = {};\n\n\t\t\t_.each(localData, function(series) {\n\t\t\t\tyearsForSeries[series.id] = {};\n\t\t\t\t_.each(series.values, function(d, i) {\n\t\t\t\t\tallYears[d.x] = true;\n\t\t\t\t\tyearsForSeries[series.id][d.x] = true;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t_.each(localData, function(series) {\n\t\t\t\t_.each(Object.keys(allYears), function(year) {\n\t\t\t\t\tyear = parseInt(year);\n\t\t\t\t\tif (!yearsForSeries[series.id][year])\n\t\t\t\t\t\tseries.values.push({ x: year, y: 0, time: year, fake: true });\n\t\t\t\t});\n\n\t\t\t\tseries.values = _.sortBy(series.values, function(d) { return d.x; });\n\t\t\t});\n\n\t\t\treturn localData;\n\t\t},\n\n\t\t// Zero pads for every single year in the data\n\t\tzeroPadDataRange: function(localData) {\n\t\t\tvar minYear = Infinity, maxYear = -Infinity;\n\t\t\t_.each(localData, function(series) {\n\t\t\t\tminYear = Math.min(minYear, series.values[0].x);\n\t\t\t\tmaxYear = Math.max(maxYear, series.values[series.values.length-1].x);\n\t\t\t});\n\n\t\t\tvar yearsForSeries = {};\n\t\t\t_.each(localData, function(series) {\n\t\t\t\tyearsForSeries[series.id] = {};\n\t\t\t\t_.each(series.values, function(d, i) {\n\t\t\t\t\tyearsForSeries[series.id][d.x] = true;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t_.each(localData, function(series) {\n\t\t\t\tfor (var year = minYear; year <= maxYear; year++) {\t\t\t\t\t\n\t\t\t\t\tif (!yearsForSeries[series.id][year])\n\t\t\t\t\t\tseries.values.push({ x: year, y: 0, time: year, fake: true });\n\t\t\t\t}\n\t\t\t\tseries.values = _.sortBy(series.values, function(d) { return d.x; });\n\t\t\t});\n\n\t\t\treturn localData;\t\t\t\n\t\t},\n\n\t\ttransformDataForStackedArea: function() {\n\t\t\tif (App.ChartModel.get(\"group-by-variables\") == false)\n\t\t\t\treturn this.zeroPadData(this.transformDataForLineChart());\n\n\t\t\tvar dimensions = this.dimensions,\n\t\t\t\tvariableData = this.get('variableData'),\n\t\t\t\tvariables = variableData.variables,\n\t\t\t\tentityKey = variableData.entityKey,\n\t\t\t\t// Group-by-variable chart only has one selected country\n\t\t\t\tselectedCountry = _.values(this.getSelectedCountriesById())[0],\n\t\t\t\tlocalData = [],\n\t\t\t\tminTransformedYear = Infinity,\n\t\t\t\tmaxTransformedYear = -Infinity;\n\n\t\t\t_.each(dimensions, function(dimension) {\n\t\t\t\tvar variable = variables[dimension.variableId];\n\n\t\t\t\tvar series = {\n\t\t\t\t\tid: variable.id,\n\t\t\t\t\tkey: dimension.displayName || variable.name,\n\t\t\t\t\tentityName: selectedCountry.name,\n\t\t\t\t\tvalues: []\n\t\t\t\t};\n\n\t\t\t\tfor (var i = 0; i < variable.years.length; i++) {\n\t\t\t\t\tvar year = parseInt(variable.years[i]),\n\t\t\t\t\t\tvalue = parseFloat(variable.values[i]),\n\t\t\t\t\t\tentityId = variable.entities[i];\n\n\t\t\t\t\tif (entityId != selectedCountry.id) continue;\n\n\t\t\t\t\tseries.values.push({ x: year, y: value, time: year });\n\t\t\t\t\tminTransformedYear = Math.min(minTransformedYear, year);\n\t\t\t\t\tmaxTransformedYear = Math.max(maxTransformedYear, year);\n\t\t\t\t}\n\n\t\t\t\tlocalData.push(series);\n\t\t\t});\n\n\t\t\tthis.minTransformedYear = minTransformedYear;\n\t\t\tthis.maxTransformedYear = maxTransformedYear;\n\t\t\treturn this.zeroPadData(localData);\n\t\t},\n\n\t\tmakeCategoryTransform: function(property, values) {\n\t\t\tvar colors = [ \"#aec7e8\", \"#ff7f0e\", \"#1f77b4\", \"#ffbb78\", \"#2ca02c\", \"#98df8a\", \"#d62728\", \"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"c49c94\", \"e377c2\", \"f7b6d2\", \"7f7f7f\", \"c7c7c7\", \"bcbd22\", \"dbdb8d\", \"17becf\", \"9edae5\", \"1f77b4\" ];\n\t\t\tvar shapes = [ \"circle\", \"cross\", \"triangle-up\", \"triangle-down\", \"diamond\", \"square\" ];\n\n\t\t\tvar outputValues = property == \"color\" ? colors : shapes,\n\t\t\t\tindex = 0,\n\t\t\t\tcategoryTransform = {};\n\n\t\t\t_.each(_.sortBy(_.uniq(values)), function(value) { \n\t\t\t\tcategoryTransform[value] = outputValues[index];\n\t\t\t\tindex += 1;\n\t\t\t\tif (index >= outputValues.length) index = 0;\n\t\t\t});\n\n\t\t\treturn categoryTransform;\n\t\t},\n\n\t\ttransformDataForScatterPlot: function() {\n\t\t\tvar dimensions = this.dimensions,\n\t\t\t\tvariableData = this.get('variableData'),\n\t\t\t\tvariables = variableData.variables,\n\t\t\t\tentityKey = variableData.entityKey,\n\t\t\t\tselectedCountriesById = this.getSelectedCountriesById(),\n\t\t\t\tseriesByEntity = {},\n\t\t\t\t// e.g. for colors { var_id: { 'Oceania': '#ff00aa' } }\n\t\t\t\tcategoryTransforms = {},\t\t\t\t\n\t\t\t\tlocalData = [];\n\n\t\t\tvar latestYearInData = _.max(_.map(variables, function(v) { return _.max(v.years); }));\n\n\t\t\t_.each(dimensions, function(dimension) {\n\t\t\t\tvar variable = variables[dimension.variableId],\n\t\t\t\t    targetYear = parseInt(dimension.targetYear),\n\t\t\t\t    targetMode = dimension.mode,\n\t\t\t\t    tolerance = parseInt(dimension.tolerance),\n\t\t\t\t    maximumAge = parseInt(dimension.maximumAge),\n\t\t\t\t    isCategorical = _.include(['color', 'shape'], dimension.property),\n\t\t\t\t    categoryTransform = categoryTransforms[variable.id];\n\n\t\t\t\tif (isCategorical && !categoryTransform) {\n\t\t\t\t\tcategoryTransform = this.makeCategoryTransform(dimension.property, variable.values);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < variable.years.length; i++) {\n\t\t\t\t\tvar year = parseInt(variable.years[i]),\n\t\t\t\t\t\tvalue = variable.values[i],\n\t\t\t\t\t\tentityId = variable.entities[i],\n\t\t\t\t\t\tentity = selectedCountriesById[entityId],\n\t\t\t\t\t\tseries = seriesByEntity[entityId];\t\t\t\t\t\t\n\n\t\t\t\t\t// Scatterplot defaults to showing all countries if none selected\n\t\t\t\t\tif (!_.isEmpty(selectedCountriesById) && !entity) continue;\n\n\t\t\t\t\tif (!series) {\n\t\t\t\t\t\tseries = {\n\t\t\t\t\t\t\tvalues: [{ time: {} }],\n\t\t\t\t\t\t\tkey: entityKey[entityId].name,\n\t\t\t\t\t\t\tentityName: entityKey[entityId].name,\n\t\t\t\t\t\t\tid: entityId\n\t\t\t\t\t\t};\n\t\t\t\t\t\tseriesByEntity[entityId] = series;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Categorical data like color or shape just goes straight on the series\n\t\t\t\t\tif (isCategorical) {\n\t\t\t\t\t\tseries[dimension.property] = categoryTransform[value];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetMode === \"specific\") {\n\t\t\t\t\t\t// Not within target year range, ignore\n\t\t\t\t\t\tif (year < targetYear-tolerance || year > targetYear+tolerance)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// Make sure we use the closest year within tolerance (favoring later years)\n\t\t\t\t\t\tvar current = series.values[0].time[dimension.property];\n\t\t\t\t\t\tif (current && Math.abs(current - targetYear) < Math.abs(year - targetYear))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (targetMode == \"latest\" && !isNaN(maximumAge)) {\n\t\t\t\t\t\tif (year < latestYearInData-maximumAge)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// All good, put the data in. Note that a scatter plot only has one value per entity.\n\t\t\t\t\tvar datum = series.values[0];\n\t\t\t\t\tdatum[dimension.property] = parseFloat(value);\n\t\t\t\t\tdatum.time[dimension.property] = year;\n\t\t\t\t}\n\t\t\t}.bind(this));\n\n\t\t\t// Exclude any countries which lack data for one or more variables\n\t\t\t_.each(seriesByEntity, function(series) {\n\t\t\t\tvar isComplete = _.every(dimensions, function(dim) {\n\t\t\t\t\treturn dim.property == \"color\" || series.values[0].hasOwnProperty(dim.property);\n\t\t\t\t});\n\n\t\t\t\tif (isComplete)\n\t\t\t\t\tlocalData.push(series);\n\t\t\t}.bind(this));\n\n\t\t\tthis.minTransformedYear = _.min(_.map(localData, function(entityData) {\n\t\t\t\treturn _.min(_.values(entityData.values[0].time));\n\t\t\t}));\n\t\t\tthis.maxTransformedYear = _.max(_.map(localData, function(entityData) {\n\t\t\t\treturn _.max(_.values(entityData.values[0].time));\n\t\t\t}));\n\n\t\t\treturn localData;\n\t\t},\n\n\t\tgetSourceDescHtml: function(dimension) {\n\t\t\tvar variableData = this.get(\"variableData\"),\n\t\t\t\tvariable = variableData.variables[dimension.variableId],\n\t\t\t\tsource = variable.source;\n\n\t\t\tvar displayName = _.isEmpty(dimension.displayName) ? variable.name : dimension.displayName;\n\t\t\tvar hideDimName = _.isEmpty(dimension.name) || _.size(this.get(\"variableData\").variables) == 1;\n\n\t\t\tvar html = \"<div class='datasource-wrapper'>\";\n\t\t\thtml += (hideDimName ? \"<h2>Data</h2>\" : \"<h2>Data for \" + dimension.name + \": </h2>\");\n\t\t\thtml += \"<div class='datasource-header'>\" +\n\t\t\t\t\t    \"<h3><span class='datasource-property'>Dataset:</span>\" + variable.dataset_name + \"</h3>\";\n\n\t\t\tif (variable.name != variable.dataset_name)\n\t\t\t\thtml += \"<h4><span class='datasource-property'>Variable:</span>\" + variable.name + \"</h4>\";\n\n\t\t\thtml += \"</div>\";\n\n\t\t\thtml += \"<table>\";\n\t\t\tif (displayName != variable.name)\n\t\t\t\thtml += \"<tr><td><span class='datasource-property'>Display name</span></td><td>\" + displayName + \"</td></tr>\";\n\t\t\tif (variable.description)\n\t\t\t\thtml += \"<tr><td><span class='datasource-property'>Definition</span></td><td>\" + variable.description + \"</td></tr>\";\n\t\t\tif (variable.unit)\n\t\t\t\thtml += \"<tr><td><span class='datasource-property'>Unit</span></td><td>\" + variable.unit + \"</td></tr>\";\n\t\t\tif (variable.created_at && variable.created_at != \"0000-00-00 00:00:00\")\n\t\t\t\thtml += \"<tr><td><span class='datasource-property'>Uploaded</span></td><td>\" + variable.created_at + \"</td></tr>\";\n\t\t\thtml += \"</table>\";\n\t\t\t\n\t\t\thtml += source.description;\n\t\t\thtml += \"</div>\"\n\t\t\treturn html;\n\t\t},\n\n\t\ttransformDataForSources: function() {\n\t\t\tvar variableData = this.get(\"variableData\");\t\t\t\n\t\t\tif (!variableData) return [];\n\n\t\t\treturn _.map(this.dimensions, function(dimension) {\n\t\t\t\tvar variable = variableData.variables[dimension.variableId],\n\t\t\t\t\tsource = _.extend({}, variable.source);\n\n\t\t\t\tsource.description = this.getSourceDescHtml(dimension);\n\t\t\t\treturn source;\n\t\t\t}.bind(this));\n\t\t},\n\n\t\ttransformData: function() {\n\t\t\tvar variableData = this.get(\"variableData\");\n\t\t\tif (!variableData) return [];\n\n\t\t\tvar chartType = App.ChartModel.get(\"chart-type\");\n\t\t\tif (chartType == App.ChartType.LineChart)\n\t\t\t\treturn this.transformDataForLineChart();\n\t\t\telse if (chartType == App.ChartType.ScatterPlot)\n\t\t\t\treturn this.transformDataForScatterPlot();\n\t\t\telse if (chartType == App.ChartType.StackedArea)\n\t\t\t\treturn this.transformDataForStackedArea();\t\n\t\t\telse\n\t\t\t\treturn this.transformDataForLineChart();\n\t\t},\n\t});\n})();",";( function() {\t\n\t\"use strict\";\n\n\twindow.App = window.App || {};\n\tApp.Views = App.Views || {};\n\tApp.Views.Chart = App.Views.Chart || {};\t\n\n\tApp.Views.Chart.Header = Backbone.View.extend({\n\t\tDEFAULT_LOGO_URL: \"uploads/26538.png\",\n\n\t\tel: \"#chart-view .chart-header\",\n\t\tevents: {},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\tthis.parentView = options.parentView;\n\n\t\t\tthis.logo = d3.select(\".logo-svg\");\n\t\t\tthis.partnerLogo = d3.select(\".partner-logo-svg\");\n\t\t\tthis.$tabs = $(\".header-tab\");\n\n\t\t\tApp.ChartModel.on( \"change\", this.render, this );\n\t\t},\n\n\t\trender: function(callback) {\n\t\t\tvar chartName = App.ChartModel.get( \"chart-name\" ),\n\t\t\t\tchartSubname = App.ChartModel.get( \"chart-subname\" ) || \"\",\n\t\t\t\taddCountryMode = App.ChartModel.get( \"add-country-mode\" ),\n\t\t\t\tselectedCountries = App.ChartModel.get(\"selected-countries\"),\n\t\t\t\tlogoPath = App.ChartModel.get(\"logo\"),\n\t\t\t\tpartnerLogoPath = App.ChartModel.get(\"second-logo\"),\n\t\t\t\tpartnerLogoUrl = partnerLogoPath && Global.rootUrl + \"/\" + partnerLogoPath,\n\t\t\t\ttabs = App.ChartModel.get( \"tabs\" );\n\n\t\t\t/* Figure out the final header text */\n\n\t\t\tthis.updateTime();\n\t\t\tchartName = this.replaceContextPlaceholders(chartName);\n\t\t\tchartSubname = this.replaceContextPlaceholders(chartSubname);\n\t\t\tif (this.mapDisclaimer) chartSubname += this.mapDisclaimer;\n\n\t\t\t/* Position the logos first, because we shall need to wrap the text around them.\n\t\t\t   Currently our logo is SVG but we must use image uris for the partner logos.\n\t\t\t   TODO: Convert partner logos to SVG too, so that they can be scaled. */\n\n\t\t\tvar svg = d3.select(\"svg\"),\n\t\t\t\tsvgBounds = svg.node().getBoundingClientRect(),\n\t\t\t\tsvgWidth = svgBounds.width,\n\t\t\t\tsvgHeight = svgBounds.height,\n\t\t\t\tg = svg.select(\".chart-header-svg\");\n\n\t\t\tvar logoWidth = this.logo.node().getBBox().width,\n\t\t\t\tscaleFactor =  0.3,\n\t\t\t\tlogoX = svgWidth - logoWidth*scaleFactor;\n\t\t\tthis.logo.attr(\"transform\", \"translate(\" + logoX + \", 5) scale(\" + scaleFactor + \", \" + scaleFactor + \")\");\n\t\t\tthis.logo.style(\"visibility\", \"inherit\");\n\n\t\t\tvar renderText = function(availableWidth) {\n\t\t\t\tvar chartNameText = g.select(\".chart-name-svg\");\n\t\t\t\tvar baseUrl = Global.rootUrl + \"/\" + App.ChartModel.get(\"chart-slug\"),\n\t\t\t\t\tqueryParams = owid.getQueryParams(),\n\t\t\t\t\tqueryStr = owid.queryParamsToStr(queryParams),\t\t\t\t\n\t\t\t\t\tcanonicalUrl = baseUrl + queryStr;\n\n\t\t\t\tvar linkedName = \"<a href='\" + canonicalUrl + \"' target='_blank'>\" + chartName + \"</a>\";\n\t\t\t\towid.svgSetWrappedText(chartNameText, linkedName, availableWidth - 10, { lineHeight: 1.1 });\n\t\t\t\tdocument.title = chartName + \" - Our World In Data\";\n\n\t\t\t\tvar chartSubnameText = g.select(\".chart-subname-svg\")\n\t\t\t\t\t.attr(\"y\", chartNameText.node().getBoundingClientRect().bottom - svgBounds.top);\n\n\t\t\t\towid.svgSetWrappedText(chartSubnameText, chartSubname, availableWidth - 10, { lineHeight: 1.3 });\n\n\t\t\t\tg.select(\".header-bg-svg\").remove();\n\t\t\t\tvar bgHeight = g.node().getBoundingClientRect().height + 20;\n\t\t\t\tg.insert(\"rect\", \"*\")\n\t\t\t\t\t.attr(\"class\", \"header-bg-svg\")\n\t\t\t\t\t.attr(\"x\", 0)\n\t\t\t\t\t.attr(\"y\", 0)\n\t\t\t\t\t.style(\"fill\", \"#fff\")\n\t\t\t\t\t.attr(\"width\", svgWidth)\n\t\t\t\t\t.attr(\"height\", bgHeight);\n\t\t\t\tthis.$tabs.attr(\"style\", \"display: none !important;\");\n\n\t\t\t\t_.each(tabs, function( v, i ) {\n\t\t\t\t\tvar tab = this.$tabs.filter(\".\" + v + \"-header-tab\");\n\t\t\t\t\ttab.show();\n\t\t\t\t}.bind(this));\n\n\t\t\t\t//for first visible tab, add class for border-left, cannot be done in pure css http://stackoverflow.com/questions/18765814/targeting-first-visible-element-with-pure-css\n\t\t\t\tthis.$tabs.removeClass( \"first\" );\n\t\t\t\tthis.$tabs.filter( \":visible:first\" ).addClass( \"first\" );\n\n\t\t\t\tthis.dispatcher.trigger(\"header-rendered\");\t\t\t\n\t\t\t\tif (_.isFunction(callback)) callback();\t\t\t\t\t\n\t\t\t}.bind(this);\n\n\t\t\tif (partnerLogoUrl) {\n\t\t\t\t// HACK (Mispy): Since SVG image elements aren't autosized, any partner logo needs to \n\t\t\t\t// be loaded separately in HTML and then the width and height extracted\n\t\t\t\tvar img = new Image();\n\t\t\t\timg.onload = function() {\n\t\t\t\t\tthis.partnerLogo.attr('width', img.width);\n\t\t\t\t\tthis.partnerLogo.attr('height', img.height);\n\t\t\n\t\t\t\t\tvar partnerLogoX = logoX - img.width - 5;\n\t\t\t\t\tthis.partnerLogo.node().setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", partnerLogoUrl);\n\t\t\t\t\tthis.partnerLogo.attr(\"transform\", \"translate(\" + partnerLogoX + \", 5)\");\t\t\t\t\n\t\t\t\t\tthis.partnerLogo.style(\"visibility\", \"inherit\");\n\n\t\t\t\t\trenderText(partnerLogoX);\n\t\t\t\t}.bind(this);\n\t\t\t\timg.src = partnerLogoUrl;\n\t\t\t} else {\n\t\t\t\trenderText(logoX);\n\t\t\t}\n\t\t},\n\n\t\tonResize: function(callback) {\n\t\t\tthis.render(callback);\n\t\t},\n\n\t\t// Replaces things like *time* and *country* with the actual time and\n\t\t// country displayed by the current chart context\n\t\treplaceContextPlaceholders: function(text) {\n\t\t\tif (s.contains(text, \"*country*\")) {\n\t\t\t\tvar selectedCountries = App.ChartModel.get(\"selected-countries\");\n\t\t\t\ttext = text.replace(\"*country*\", _.pluck(selectedCountries, \"name\").join(\", \"));\n\t\t\t}\n\n\t\t\tif (s.contains(text, \"*time\")) {\n\t\t\t\tif (!this.selectedTimeFrom) {\n\t\t\t\t\ttext = text.replace(\"*time*\", \"over time\");\n\t\t\t\t} else {\n\t\t\t\t\tvar timeFrom = owid.displayYear(this.selectedTimeFrom),\n\t\t\t\t\t\ttimeTo = owid.displayYear(this.selectedTimeTo),\n\t\t\t\t\t\ttime = this.targetYear || (timeFrom === timeTo ? timeFrom : timeFrom + \" to \" + timeTo);\t\t\t\t\n\n\t\t\t\t\ttext = text.replace(\"*time*\", time);\n\t\t\t\t\ttext = text.replace(\"*timeFrom*\", timeFrom);\n\t\t\t\t\ttext = text.replace(\"*timeTo*\", timeTo);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn text;\n\t\t},\n\n\t\tupdateTime: function() {\n\t\t\tvar tabs =\tApp.ChartModel.get( \"tabs\" ),\n\t\t\t\tactiveTab = _.find(tabs, function(tab) { return this.$tabs.filter(\".\" + tab + \"-header-tab.active\").length > 0}.bind(this));\n\n\t\t\tif (activeTab == \"map\") {\n\t\t\t\tif (this.parentView.mapTab.mapConfig)\n\t\t\t\t\tthis.updateTimeFromMap(this.parentView.mapTab);\n\t\t\t} else {\n\t\t\t\tif (this.parentView.chartTab && this.parentView.chartTab.localData)\n\t\t\t\t\tthis.updateTimeFromChart();\n\t\t\t}\n\t\t},\n\n\t\tupdateTimeFromChart: function() {\n\t\t\t//find minimum and maximum in all displayed data\n\t\t\tvar dimsString = App.ChartModel.get(\"chart-dimensions\"),\n\t\t\t\tdims = $.parseJSON( dimsString ),\n\t\t\t\tlatestAvailable = false,\n\t\t\t\ttimeFrom = App.DataModel.minTransformedYear,\n\t\t\t\ttimeTo = App.DataModel.maxTransformedYear;\n\n\t\t\tthis.selectedTimeFrom = timeFrom;\n\t\t\tthis.selectedTimeTo = timeTo;\n\t\t\tthis.mapDisclaimer = null;\n\t\t\tthis.targetYear = null;\n\t\t},\n\n\t\tupdateTimeFromMap: function(map) {\t\t\t\n\t\t\tvar timeFrom = map.minToleranceYear || map.mapConfig.targetYear,\n\t\t\t\ttimeTo = map.maxToleranceYear || map.mapConfig.targetYear,\n\t\t\t\ttargetYear = map.mapConfig.targetYear,\n\t\t\t\thasTargetYear = _.find(map.mapData, function(d) { return d.year == targetYear; }),\n\t\t\t\td = owid.displayYear;\n\n\t\t\tif (hasTargetYear && timeFrom != timeTo) {\n\t\t\t\t// The target year is in the data but we're displaying a range, meaning not available for all countries\n\t\t\t\tthis.mapDisclaimer = \" Since some observations for \" + d(targetYear) + \" are not available the map displays the closest available data (\" + d(timeFrom) + \" to \" + d(timeTo) + \").\";\n\t\t\t} else if (!hasTargetYear && timeFrom != timeTo) {\n\t\t\t\t// The target year isn't in the data at all and we're displaying a range of other nearby values\n\t\t\t\tthis.mapDisclaimer = \" Since observations for \" + d(targetYear) + \" are not available the map displays the closest available data (\" + d(timeFrom) + \" to \" + d(timeTo) + \").\";\n\t\t\t} else if (!hasTargetYear && timeFrom == timeTo && timeFrom != targetYear) {\n\t\t\t\t// The target year isn't in the data and we're displaying some other single year\n\t\t\t\tthis.mapDisclaimer = \" Since observations for \" + d(targetYear) + \" are not available the map displays the closest available data (from \" + d(timeFrom) + \").\";\n\t\t\t} else if (!hasTargetYear) {\n\t\t\t\tthis.mapDisclaimer = \" No observations are available for this year.\";\n\t\t\t} else {\n//\t\t\t\tthis.mapDisclaimer = \"<span style='visibility: hidden;'>A rather long placeholder to ensure that the text flow remains the same when changing between various years.</span>\";\n\t\t\t\tthis.mapDisclaimer = null;\n\t\t\t}\n\n\t\t\tthis.selectedTimeFrom = timeFrom;\n\t\t\tthis.selectedTimeTo = timeTo;\n\t\t\tthis.timeGoesToLatest = false;\n\t\t\tthis.targetYear = targetYear;\n\t\t},\n\n\t});\n\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Footer\");\n\n\tApp.Views.Chart.Footer = Backbone.View.extend({\n\t\tel: \"#chart-view .footer-btns\",\n\t\tevents: {\n\t\t\t\"click .embed-btn\": \"onEmbed\"\n\t\t},\n\n\t\tinitialize: function(options) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\tthis.$chartLinkBtn = this.$el.find(\".chart-link-btn\");\n\t\t\tthis.$tweetBtn = this.$el.find(\".tweet-btn\");\n\t\t\tthis.$facebookBtn = this.$el.find(\".facebook-btn\");\n\t\t\tthis.$embedBtn = this.$el.find(\".embed-btn\");\n\t\t\tthis.$downloadPNGButton = this.$el.find(\".download-image-btn\");\n\t\t\tthis.$downloadSVGButton = this.$el.find(\".download-svg-btn\");\n\t\t\tthis.$embedModal = $(\".embed-modal\");\n\t\t\tthis.$embedModal.appendTo(\"body\");\t\t\t\n\n\t\t\tApp.ChartModel.on(\"change\", this.render.bind(this));\n\t\t\tthis.dispatcher.on(\"header-rendered\", this.updateSharingButtons.bind(this));\n\t\t\t$(window).on(\"query-change\", this.updateSharingButtons.bind(this));\n\t\t},\n\n\t\trender: function(callback) {\n\t\t\tApp.DataModel.ready(function() {\n\t\t\t\tthis.renderSVG();\n\t\t\t\tthis.updateSharingButtons();\n\t\t\t\tif (_.isFunction(callback)) callback();\n\t\t\t}.bind(this));\n\t\t},\n\n\t\trenderSVG: function(callback) {\n\t\t\tvar sources = App.DataModel.transformDataForSources(),\n\t\t\t\tsourceNames = _.uniq(_.pluck(sources, \"name\")),\n \t\t\t\tlicense = App.DataModel.get(\"variableData\").license,\n \t\t\t\tchartDesc = App.ChartModel.get(\"chart-description\"),\n\t\t\t\tfooterSvgContent = \"Data obtained from: \";\n\t\t\t\t\n\t\t\t_.each(sourceNames, function(sourceName, i) {\n\t\t\t\tif (i > 0) footerSvgContent += \", \";\n\t\t\t\tfooterSvgContent += \"<a class='source-link' href='#'>\" + sourceName + \"</a>\";\n\t\t\t});\n\n\t\t\tif (license && license.description) {\n\t\t\t\tvar desc = license.description;\n\t\t\t\tvar originUrl = App.ChartModel.get(\"data-entry-url\");\n\n\t\t\t\t// Make sure the link back to OWID is consistent\n\t\t\t\tif (originUrl && s.contains(originUrl, \"ourworldindata.org\")) {\n\t\t\t\t\tvar a = document.createElement('a');\n\t\t\t\t\ta.href = originUrl;\n\t\t\t\t\tvar path = a.pathname[0] == \"/\" ? a.pathname : \"/\" + a.pathname; // MISPY: cross-browser compat (Internet Explorer doesn't have a slash)\n\t\t\t\t\tvar finalUrl = \"https://ourworldindata.org\" + path + a.search;\n\t\t\t\t\tdesc = desc.replace(/\\*data-entry\\*/, \"<a class='origin-link' target='_blank' href='\" + finalUrl + \"'>\" + \"OurWorldInData.org\" + path + a.search + \"</a>\");\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tdesc = desc.replace(/\\*data-entry\\*/, \n\t\t\t\t\t\t\"<a class='origin-link' target='_blank' href='http://ourworldindata.org'>OurWorldInData.org</a>\");\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tfooterSvgContent += \"\\n\\n\" + desc;\n\t\t\t}\t\t\t\n\n\t\t\t// Any additional, manually inputed footer text\n\t\t\tif (chartDesc)\n\t\t\t\tfooterSvgContent += \"\\n\" + chartDesc;\n\n\t\t\tvar svg = d3.select(\"svg\"),\n\t\t\t\tsvgWidth = svg.node().getBoundingClientRect().width,\n\t\t\t\tsvgHeight = svg.node().getBoundingClientRect().height;\n\n\t\t\tsvg.selectAll(\".chart-footer-svg\").remove();\n\t\t\tvar g = svg.append(\"g\").attr(\"class\", \"chart-footer-svg\");\n\n\t\t\tvar footerText = g.append(\"text\")\n\t\t\t\t.attr(\"x\", 0)\n\t\t\t\t.attr(\"y\", 0)\n\t\t\t\t.attr(\"dy\", 0);\n\n\t\t\towid.svgSetWrappedText(footerText, footerSvgContent, svgWidth, { lineHeight: 1.2 });\n\n\t\t\t$(\".chart-footer-svg .source-link\").click(function(ev) {\n\t\t\t\tev.preventDefault();\n\t\t\t\tApp.ChartView.activateTab(\"sources\");\n\t\t\t});\n\n\t\t\tvar footerHeight = g.node().getBBox().height;\n\t\t\tg.insert(\"rect\", \"*\")\n\t\t\t\t.attr(\"x\", 0).attr(\"y\", -25)\t\t\t\n\t\t\t\t.attr(\"width\", svgWidth)\n\t\t\t\t.attr(\"height\", footerHeight + 25)\n\t\t\t\t.style(\"fill\", \"#fff\");\n\t\t\tg.attr(\"transform\", \"translate(0, \" + (svgHeight - footerHeight) + \")\");\n\n\t\t\tif (callback) callback();\n\t\t},\n\n\t\tupdateSharingButtons: function() {\n\t\t\tvar headerText = d3.select(\"title\").text().replace(\" - Our World In Data\", \"\"),\n\t\t\t\tbaseUrl = Global.rootUrl + \"/\" + App.ChartModel.get(\"chart-slug\"),\n\t\t\t\tqueryParams = owid.getQueryParams(),\n\t\t\t\tqueryStr = owid.queryParamsToStr(queryParams),\t\t\t\t\n\t\t\t\ttab = App.ChartView.activeTabName,\n\t\t\t\tcanonicalUrl = baseUrl + queryStr,\n\t\t\t\tversion = App.ChartModel.get(\"variableCacheTag\");\n\n\t\t\tthis.$chartLinkBtn.attr('href', canonicalUrl);\n\n\t\t\tvar tweetHref = \"https://twitter.com/intent/tweet/?text=\" + encodeURIComponent(headerText) + \"&url=\" + encodeURIComponent(canonicalUrl) + \"&via=MaxCRoser\";\n\t\t\tthis.$tweetBtn.attr('href', tweetHref);\n\n\t\t\tvar facebookHref = \"https://www.facebook.com/dialog/share?app_id=1149943818390250&display=page&href=\" + encodeURIComponent(canonicalUrl);\n\t\t\tthis.$facebookBtn.attr('href', facebookHref);\n\n\t\t\tif (tab == \"data\" || tab == \"sources\") {\n\t\t\t\tthis.$downloadPNGButton.hide();\n\t\t\t\tthis.$downloadSVGButton.hide();\n\t\t\t} else {\t\t\t\n\t\t\t\tvar pngHref = baseUrl + \".png\" + queryStr,\n\t\t\t\t\tsvgHref = baseUrl + \".svg\" + queryStr,\n\t\t\t\t\tdefaultSize = \"1000x700\";\n\t\t\t\tthis.$downloadPNGButton.attr('href', pngHref + (_.include(pngHref, \"?\") ? \"&\" : \"?\") + \"size=\" + defaultSize + \"&v=\" + version);\n\t\t\t\tthis.$downloadSVGButton.attr('href', svgHref + (_.include(svgHref, \"?\") ? \"&\" : \"?\") + \"size=\" + defaultSize + \"&v=\" + version);\n\t\t\t\tthis.$downloadPNGButton.show();\n\t\t\t\tthis.$downloadSVGButton.show();\n\t\t\t}\n\n\t\t\tvar iframeWidth = App.ChartModel.get(\"iframe-width\") || \"100%\";\n\t\t\tvar iframeHeight = App.ChartModel.get(\"iframe-height\") || \"660px\";\n\t\t\tvar embedCode = '<iframe src=\"' + canonicalUrl + '\" width=\"' + iframeWidth + '\" height=\"' + iframeHeight + '\" frameborder=\"0\"></iframe>';\n\t\t\tthis.$embedModal.find(\"textarea\").text(embedCode);\n\t\t},\n\n\t\tonResize: function(callback) {\n\t\t\tthis.renderSVG(callback);\n\t\t},\n\n\t\tonEmbed: function() {\n\t\t\tthis.$embedModal.modal();\n\t\t},\n\t});\n})();",";(function() {\t\n\t\"use strict\";\n\n\twindow.App = window.App || {};\n\tApp.Views = App.Views || {};\n\tApp.Views.Chart = App.Views.Chart || {};\n\n\tApp.Views.Chart.ScaleSelectors = Backbone.View.extend({\n\n\t\tel: \"#chart-view .axis-scale-selectors-wrapper\",\n\t\tevents: {\n\t\t\t\"click .axis-scale-btn\": \"onAxisScaleBtn\",\n\t\t\t\"change .axis-scale li\": \"onAxisScaleChange\"\n\t\t},\n\n\t\tinitialize: function( options ) {\n\t\t\t\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\t\n\t\t\tthis.$tabs = this.$el.find( \".header-tab\" );\n\t\t\t\n\t\t\tthis.$xAxisScale = this.$el.find( \"[data-name='x-axis-scale']\" );\n\t\t\tthis.$yAxisScale = this.$el.find( \"[data-name='y-axis-scale']\" );\n\t\t\tthis.$xAxisBtn = this.$el.find(\".x-axis-scale-selector .axis-scale-btn\");\n\t\t\tthis.$yAxisBtn = this.$el.find(\".y-axis-scale-selector .axis-scale-btn\");\n\n\n\t\t\tthis.render();\n\t\t\tApp.ChartModel.on( \"change\", this.render, this );\n\t\t},\n\n\t\trender: function() {\t\t\t\n\t\t\tvar xScale = App.ChartModel.getAxisConfig(\"x-axis\", \"axis-scale\");\n\t\t\tthis.$xAxisBtn.find('span').text(s.capitalize(xScale));\n\n\t\t\tvar yScale = App.ChartModel.getAxisConfig(\"y-axis\", \"axis-scale\");\n\t\t\tthis.$yAxisBtn.find('span').text(s.capitalize(yScale));\n\t\t},\n\n\t\tonAxisScaleBtn: function(evt) {\t\t\t\n\t\t\tevt.preventDefault();\n\n\t\t\tvar $btn = $(evt.currentTarget),\n\t\t\t\t$div = $btn.closest(\"div\"),\n\t\t\t\tdivName = $div.attr(\"data-name\"),\n\t\t\t\taxisName  = (name == \"x-axis-scale\") ? \"x-axis\" : \"y-axis\",\n\t\t\t\tcurrentScale = App.ChartModel.getAxisConfig(axisName, \"axis-scale\");\n\n\n\t\t\tif (currentScale != \"linear\") \n\t\t\t\tApp.ChartModel.setAxisConfig(axisName, \"axis-scale\", \"linear\");\n\t\t\telse\n\t\t\t\tApp.ChartModel.setAxisConfig(axisName, \"axis-scale\", \"log\");\n\t\t}\n\n\t});\t\n})();\n",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Legend\");\n\n\t// HACK (Mispy): Avoid duplication in legend when there are multiple\n\t// split series for styling purposes.\n\tfunction getData(data) {\n\t\tif (data.length == 0 || !data[0].origKey)\n\t\t\treturn data;\n\t\treturn _.filter(data, function(series) { return !series.isCopy; });\n\t}\n\n\tApp.Views.Chart.Legend = function( chartLegend ) {\n\t\n\t\t//based on https://github.com/novus/nvd3/blob/master/src/models/legend.js\n\n\t\t//============================================================\n\t\t// Public Variables with Default Settings\n\t\t//------------------------------------------------------------\n\n\t\tvar chartType = App.ChartModel.get( \"chart-type\" )\n\t\t\t, margin = {top: 5, right: 50, bottom: 5, left: 40}\n\t\t\t, width = 800\n\t\t\t, height = 20\n\t\t\t, getKey = function(d) { return d.origKey || d.key }\n\t\t\t, color = nv.utils.getColor()\n\t\t\t, padding = 40 //define how much space between legend items. - recommend 32 for furious version\n\t\t\t, rightAlign = false\n\t\t\t, updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.\n\t\t\t, radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)\n\t\t\t, expanded = false\n\t\t\t, dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange', 'addEntity')\n\t\t\t, vers = 'classic' //Options are \"classic\" and \"furious\" and \"owd\"\n\t\t\t;\n\n\t\tfunction chart(selection) {\t\t\t\n\t\t\tselection.each(function(data) {\n\t\t\t\tvar $svg = $( \"svg.nvd3-svg\" ),\n\t\t\t\t\tavailableWidth = $svg.width() - margin.left - margin.right,\n\t\t\t\t\tcontainer = d3.select(this);\n\t\t\t\t\n\t\t\t\tnv.utils.initSVG(container);\n\n\t\t\t\tvar bindableData = getData(data);\n\n\t\t\t\t//discrete bar chart needs unpack data\n\t\t\t\tif( chartType === App.ChartType.DiscreteBar ) {\n\t\t\t\t\tif( data && data.length && data[0].values ) {\n\t\t\t\t\t\tvar discreteData = _.map( data[0].values, function( v, i ) {\n\t\t\t\t\t\t\treturn { id: v.id, key: v.x, color: v.color, values: v };\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbindableData = discreteData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Setup containers and skeleton of chart\n\t\t\t\tvar wrap = container.selectAll('g.nv-custom-legend').data([bindableData]),\n\t\t\t\t//var wrap = container.selectAll('g.nv-custom-legend').data([data]),\n\t\t\t\t\tgEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-custom-legend').append('g').attr( 'class', 'nv-legend-series-wrapper' ),\n\t\t\t\t\tg = wrap.select('g');\n\n\t\t\t\twrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n\t\t\t\tvar series = g.selectAll('.nv-series')\n\t\t\t\t\t.data(function(d) {\n\t\t\t\t\t\tif(vers != 'furious') return d;\n\t\t\t\t\t\treturn d.filter(function(n) {\n\t\t\t\t\t\t\treturn expanded ? true : !n.disengaged;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t//special styling for stacked area chart legend\n\t\t\t\tif (chartType === App.ChartType.StackedArea) {\n\t\t\t\t\tcontainer.selectAll('g.nv-custom-legend').classed(\"transparent\", true);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//add entity label\n\t\t\t\tvar entityLabel = wrap.select( '.nv-entity-label' ),\n\t\t\t\t\tentityLabelText = entityLabel.select( 'text' ),\n\t\t\t\t\tentityLabelWidth = 0;\n\n\t\t\t\t//if not existing, add nv-add-btn, if not grouping by variables\n\t\t\t\tvar addEntityBtn =  wrap.select('g.nv-add-btn'),\n\t\t\t\t\tisNewAddBtn = addEntityBtn.empty();\n\t\t\t\tif (isNewAddBtn) {\n\t\t\t\t\taddEntityBtn = wrap.append('g').attr('class', 'nv-add-btn');\n\t\t\t\t\tvar addEntityBtnG = addEntityBtn.append('g').attr( { 'class': 'add-btn-path' } );\n\t\t\t\t\taddEntityBtnG.append('path').attr( { 'd': 'M15,0 L15,14', 'class': 'nv-box' } );\n\t\t\t\t\taddEntityBtnG.append('path').attr( { 'd': 'M8,7 L22,7', 'class': 'nv-box' } );\n\t\t\t\t\t//http://android-ui-utils.googlecode.com/hg-history/ac955e6376470d9599ead07b4599ef937824f919/asset-studio/dist/res/clipart/icons/refresh.svg?r=ac955e6376470d9599ead07b4599ef937824f919\n\t\t\t\t\taddEntityBtn.append('path').attr( { 'd': 'M160.469,242.194c0-44.414,36.023-80.438,80.438-80.438c19.188,0,36.711,6.844,50.5,18.078L259.78,209.93l99.945,11.367    l0.805-107.242l-30.766,29.289c-23.546-21.203-54.624-34.164-88.804-34.164c-73.469,0-133.023,59.562-133.023,133.016    c0,2.742,0.242-2.266,0.414,0.445l53.68,7.555C161.03,245.108,160.469,247.562,160.469,242.194z M371.647,237.375l-53.681-7.555    c1.017,5.086,1.556,2.617,1.556,7.992c0,44.414-36.008,80.431-80.43,80.431c-19.133,0-36.602-6.798-50.383-17.97l31.595-30.078    l-99.93-11.366l-0.812,107.25l30.789-29.312c23.531,21.141,54.57,34.055,88.688,34.055c73.468,0,133.023-59.555,133.023-133.008    C372.062,235.078,371.812,240.085,371.647,237.375z', 'class': 'nv-box change-btn-path', 'transform': 'scale(.04) translate(150,-50)' } );\n\t\t\t\t\taddEntityBtn.append('text').attr( {'x':28,'y':11} ).text('Add country');\n\t\t\t\t\taddEntityBtn.on('click', function(d, i) {\n\t\t\t\t\t\tdispatch.addEntity();\n\t\t\t\t\t\td3.event.stopImmediatePropagation();\n\t\t\t\t\t});\n\t\t\t\t\taddEntityBtn.insert('rect', '*').attr('class', 'add-btn-bg');\n\t\t\t\t}\n\n\t\t\t\t//based on selected countries selection hide or show addEntityBtn\n\t\t\t\tif (_.isEmpty(App.ChartModel.get(\"selected-countries\"))) {\n\t\t\t\t\taddEntityBtn.attr( \"display\", \"none\" );\n\t\t\t\t} else {\n\t\t\t\t\taddEntityBtn.attr( \"display\", \"block\" );\n\t\t\t\t}\n\n\t\t\t\tvar addCountryMode = App.ChartModel.get( \"add-country-mode\" );\n\t\t\t\tif (addCountryMode === \"add-country\") {\n\t\t\t\t\taddEntityBtn.select(\"text\" ).text(\"Add country\");\n\t\t\t\t\taddEntityBtn.select(\".add-btn-path\" ).attr( \"display\", \"block\");\n\t\t\t\t\taddEntityBtn.select(\".change-btn-path\" ).attr( \"display\", \"none\");\n\t\t\t\t\taddEntityBtn.attr( \"display\", \"block\" );\n\t\t\t\t} else if (addCountryMode === \"change-country\") {\n\t\t\t\t\taddEntityBtn.select(\".add-btn-path\").attr(\"display\", \"none\");\n\t\t\t\t\taddEntityBtn.select(\".change-btn-path\").attr(\"display\", \"block\");\n\t\t\t\t\taddEntityBtn.select(\"text\").text(\"Change country\");\n\t\t\t\t\taddEntityBtn.attr(\"display\", \"block\");\n\t\t\t\t} else {\n\t\t\t\t\taddEntityBtn.attr(\"display\", \"none\");\n\t\t\t\t}\n\n\t\t\t\tif (isNewAddBtn) {\n\t\t\t\t\taddEntityBtn.select(\"rect\")\n\t\t\t\t\t\t.attr({ width: addEntityBtn.node().getBoundingClientRect().width + 15, height: '25', transform: 'translate(0,-5)' });\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tvar seriesEnter = series.enter().append('g').attr('class', function(d) { return 'nv-series nv-series-' + d.id; } ),\n\t\t\t\t\tseriesShape, seriesRemove;\n\n\t\t\t\tvar versPadding = 30;\n\t\t\t\tseriesEnter.append('rect')\n\t\t\t\t\t.style('stroke-width', 2)\n\t\t\t\t\t.attr('class','nv-legend-symbol');\n\n\t\t\t\t//enable removing countries only if Add/Replace country button present\n\t\t\t\tif( addCountryMode == \"add-country\" && !App.ChartModel.get( \"group-by-variables\" ) ) {\n\t\t\t\t\tvar removeBtns = seriesEnter.append('g')\n\t\t\t\t\t\t.attr('class', 'nv-remove-btn')\n\t\t\t\t\t\t.attr('transform', 'translate(10,10)');\n\t\t\t\t\tremoveBtns.append('path').attr( { 'd': 'M0,0 L7,7', 'class': 'nv-box' } );\n\t\t\t\t\tremoveBtns.append('path').attr( { 'd': 'M7,0 L0,7', 'class': 'nv-box' } );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tseriesShape = series.select('.nv-legend-symbol');\n\t\t\t\t\n\t\t\t\tseriesEnter.append('text')\n\t\t\t\t\t.attr('text-anchor', 'start')\n\t\t\t\t\t.attr('class','nv-legend-text')\n\t\t\t\t\t.attr('dy', '.32em')\n\t\t\t\t\t.attr('dx', '0');\n\n\t\t\t\tvar seriesText = series.select('text.nv-legend-text'),\n\t\t\t\t\tseriesRemove = series.select('.nv-remove-btn');\n\n\t\t\t\tseries\n\t\t\t\t\t.on('mouseover', function(d,i) {\n\t\t\t\t\t\tchartLegend.dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects\n\t\t\t\t\t})\n\t\t\t\t\t.on('mouseout', function(d,i) {\n\t\t\t\t\t\tchartLegend.dispatch.legendMouseout(d,i);\n\t\t\t\t\t})\n\t\t\t\t\t.on('click', function(d,i) {\n\t\t\t\t\t\tif (App.ChartModel.get(\"group-by-variables\") || addCountryMode !== \"add-country\") {\n\t\t\t\t\t\t\t//if displaying variables, instead of removing, use original version just to turn stuff off\n\t\t\t\t\t\t\t//original version, when clicking country label just deactivates it\n\t\t\t\t\t\t\tchartLegend.dispatch.legendClick(d,i);\n\t\t\t\t\t\t\t// make sure we re-get data in case it was modified\n\t\t\t\t\t\t\tvar data = getData(series.data());\n\t\t\t\t\t\t\tif (updateState) {\n\t\t\t\t\t\t\t\tif(expanded) {\n\t\t\t\t\t\t\t\t\td.disengaged = !d.disengaged;\n\t\t\t\t\t\t\t\t\td.userDisabled = d.userDisabled == undefined ? !!d.disabled : d.userDisabled;\n\t\t\t\t\t\t\t\t\td.disabled = d.disengaged || d.userDisabled;\n\t\t\t\t\t\t\t\t} else if (!expanded) {\n\t\t\t\t\t\t\t\t\td.disabled = !d.disabled;\n\t\t\t\t\t\t\t\t\td.userDisabled = d.disabled;\n\t\t\t\t\t\t\t\t\tvar engaged = data.filter(function(d) { return !d.disengaged; });\n\t\t\t\t\t\t\t\t\tif (engaged.every(function(series) { return series.userDisabled })) {\n\t\t\t\t\t\t\t\t\t\t//the default behavior of NVD3 legends is, if every single series\n\t\t\t\t\t\t\t\t\t\t// is disabled, turn all series' back on.\n\t\t\t\t\t\t\t\t\t\tdata.forEach(function(series) {\n\t\t\t\t\t\t\t\t\t\t\tseries.disabled = series.userDisabled = false;\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchartLegend.dispatch.stateChange({\n\t\t\t\t\t\t\t\t\tdisabled: data.map(function(d) { return !!d.disabled; }),\n\t\t\t\t\t\t\t\t\tdisengaged: data.map(function(d) { return !!d.disengaged; })\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//when clicking country label, remove the country\n\t\t\t\t\t\t\td3.event.stopImmediatePropagation();\n\t\t\t\t\t\t\t//remove series straight away, so we don't have to wait for response from server\n\t\t\t\t\t\t\tseries[0][i].remove();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar id = d.id;\n\t\t\t\t\t\t\t//in case of multivarient chart\n\t\t\t\t\t\t\t//id could be string or integer\n\t\t\t\t\t\t\tif (id.indexOf && id.indexOf(\"-\") > 0 ) {\n\t\t\t\t\t\t\t\tid = parseInt( id.split( \"-\" )[ 0 ], 10 );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tid = parseInt( id, 10 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tApp.ChartModel.removeSelectedCountry(d.entityName);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\tseries.classed('nv-disabled', function(d) { return d.userDisabled; });\n\t\t\t\tseries.exit().remove();\n\n\t\t\t\tseriesText\n\t\t\t\t\t.attr('fill', setTextColor)\n\t\t\t\t\t.text(getKey);\n\n\t\t\t\tvar transformX = 0, transformY = 0;\n\t\t\t\tseries.each(function(d, i) {\n\t\t\t\t\tvar legendText = d3.select(this).select('text');\n\t\t\t\t\tvar nodeTextLength = legendText.node().getComputedTextLength();\n\n\t\t\t\t\tif (transformX+nodeTextLength > availableWidth)  {\n\t\t\t\t\t\ttransformY += versPadding;\n\t\t\t\t\t\ttransformX = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\td3.select(this).attr(\"transform\", \"translate(\" + transformX + \",\" + transformY + \")\");\n\n\t\t\t\t\ttransformX += nodeTextLength + padding;\n\t\t\t\t});\n\t\t\t\tvar legendWidth = availableWidth;\n\n\t\t\t\t//position legend as far right as possible within the total width\n\t\t\t\tif (rightAlign) {\n\t\t\t\t\tg.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tg.attr('transform', 'translate(' + entityLabelWidth + ',' + margin.top + ')');\n\t\t\t\t}\n\n\t\t\t\theight = margin.top + margin.bottom + transformY + versPadding;// + (Math.ceil(seriesWidths.length / seriesPerRow) * versPadding);\n\n\t\t\t\t// Size rectangles after text is placed\n\t\t\t\tseriesShape\n\t\t\t\t\t.attr('width', function(d,i) {\n\t\t\t\t\t\t//position remove btn\n\t\t\t\t\t\tvar width = seriesText[0][i].getComputedTextLength() + 5;\n\t\t\t\t\t\td3.select( seriesRemove[0][i] ).attr( 'transform', 'translate(' + width + ',-3)' );\n\t\t\t\t\t\treturn width+25;\n\t\t\t\t\t})\n\t\t\t\t\t.attr('height', 24)\n\t\t\t\t\t.attr('y', -12)\n\t\t\t\t\t.attr('x', -12);\n\n\t\t\t\t// The background for the expanded legend (UI)\n\t\t\t\tgEnter.insert('rect',':first-child')\n\t\t\t\t\t.attr('class', 'nv-legend-bg')\n\t\t\t\t\t.attr('fill', '#eee')\n\t\t\t\t\t// .attr('stroke', '#444')\n\t\t\t\t\t.attr('opacity',0);\n\n\t\t\t\tvar seriesBG = g.select('.nv-legend-bg');\n\n\t\t\t\tseriesBG\n\t\t\t\t.transition().duration(300)\n\t\t\t\t\t.attr('x', -versPadding )\n\t\t\t\t\t.attr('width', legendWidth + versPadding - 12)\n\t\t\t\t\t.attr('height', height )\n\t\t\t\t\t.attr('y', -margin.top - 10)\n\t\t\t\t\t.attr('opacity', expanded ? 1 : 0);\n\n\t\t\t\tseriesShape\n\t\t\t\t\t.style('fill', setBGColor)\n\t\t\t\t\t.style('fill-opacity', setBGOpacity)\n\t\t\t\t\t.style('stroke', setBGColor);\n\n\t\t\t\t//position add btn\n\t\t\t\tif (series.size()) {\n\t\t\t\t\tvar seriesArr = series[0];\n\t\t\t\t\tif( seriesArr && seriesArr.length ) {\n\t\t\t\t\t\t//fetch last element to know its width\n\t\t\t\t\t\tvar lastEl = seriesArr[ seriesArr.length-1 ],\n\t\t\t\t\t\t\t//need rect inside element that has set width\n\t\t\t\t\t\t\tlastRect = d3.select( lastEl ).select( \"rect\" ),\n\t\t\t\t\t\t\tlastRectWidth = lastRect.attr( \"width\" );\n\t\t\t\t\t\t//position add btn\n\t\t\t\t\t\ttransformX -= 3;\n\t\t\t\t\t\t//centering\n\t\t\t\t\t\ttransformY = +transformY - 3;\n\t\t\t\t\t\t//check for right edge\n\t\t\t\t\t\tvar buttonWidth = 120, buttonHeight = 35;\n\t\t\t\t\t\tif( ( transformX + buttonWidth ) > availableWidth ) {\n\t\t\t\t\t\t\t//make sure we have button\n\t\t\t\t\t\t\tvar addEntityDisplay = addEntityBtn.attr( \"display\" );\n\t\t\t\t\t\t\tif( addEntityDisplay !== \"none\" ) {\n\t\t\t\t\t\t\t\ttransformX = 0;//availableWidth - buttonWidth;\n\t\t\t\t\t\t\t\ttransformY += buttonHeight;\n\t\t\t\t\t\t\t\t//update whole chart height as well\n\t\t\t\t\t\t\t\theight += buttonHeight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddEntityBtn.attr( \"transform\", \"translate( \" + transformX + \", \" + transformY + \")\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfunction setTextColor(d,i) {\n\t\t\t\tif(vers != 'furious' && vers != 'owd') return '#000';\n\t\t\t\tif(expanded) {\n\t\t\t\t\treturn d.disengaged ? '#000' : '#fff';\n\t\t\t\t} else if (!expanded) {\n\t\t\t\t\tif(!d.color) d.color = color(d,i);\n\t\t\t\t\treturn !!d.disabled ? '#666' : '#fff';\n\t\t\t\t\t//return !!d.disabled ? d.color : '#fff';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction setBGColor(d,i) {\n\t\t\t\tif(expanded && (vers == 'furious' || vers == 'owd')) {\n\t\t\t\t\treturn d.disengaged ? '#eee' : d.color || color(d,i);\n\t\t\t\t} else {\n\t\t\t\t\treturn d.color || color(d,i);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfunction setBGOpacity(d,i) {\n\t\t\t\tif(expanded && (vers == 'furious' || vers == 'owd')) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn !!d.disabled ? 0 : 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn chart;\n\t\t}\n\n\t\t//============================================================\n\t\t// Expose Public Variables\n\t\t//------------------------------------------------------------\n\n\t\tchart.dispatch = dispatch;\n\t\tchart.options = nv.utils.optionsFunc.bind(chart);\n\n\t\tchart._options = Object.create({}, {\n\t\t\t// simple options, just get/set the necessary values\n\t\t\twidth:      {get: function(){return width;}, set: function(_){width=_;}},\n\t\t\theight:     {get: function(){return height;}, set: function(_){height=_;}},\n\t\t\tkey:        {get: function(){return getKey;}, set: function(_){getKey=_;}},\n\t\t\trightAlign:    {get: function(){return rightAlign;}, set: function(_){rightAlign=_;}},\n\t\t\tpadding:       {get: function(){return padding;}, set: function(_){padding=_;}},\n\t\t\tupdateState:   {get: function(){return updateState;}, set: function(_){updateState=_;}},\n\t\t\tradioButtonMode:    {get: function(){return radioButtonMode;}, set: function(_){radioButtonMode=_;}},\n\t\t\texpanded:   {get: function(){return expanded;}, set: function(_){expanded=_;}},\n\t\t\tvers:   {get: function(){return vers;}, set: function(_){vers=_;}},\n\n\t\t\t// options that require extra logic in the setter\n\t\t\tmargin: {get: function(){return margin;}, set: function(_){\n\t\t\t\tmargin.top    = _.top    !== undefined ? _.top    : margin.top;\n\t\t\t\tmargin.right  = _.right  !== undefined ? _.right  : margin.right;\n\t\t\t\tmargin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n\t\t\t\tmargin.left   = _.left   !== undefined ? _.left   : margin.left;\n\t\t\t}},\n\t\t\tcolor:  {get: function(){return color;}, set: function(_){\n\t\t\t\tcolor = nv.utils.getColor(_);\n\t\t\t}}\n\t\t});\n\n\t\tchart.highlightPoint = function(evt) {\n\t\t\tchart.clearHighlight();\n\t\t\tvar id = ( evt && evt.point )? evt.point.id: \"\";\n\t\t\tif( id ) {\n\t\t\t\td3.selectAll( \".nv-custom-legend .nv-series-\" + id ).classed( \"highlight\", true );\n\t\t\t}\n\t\t};\n\t\tchart.clearHighlight = function(evt) {\n\t\t\td3.selectAll( \".nv-custom-legend .nv-series\" ).classed( \"highlight\", false );\n\t\t};\n\n\t\tnv.utils.initOptions(chart);\n\n\t\treturn chart;\n\t};\n})();",";(function() {\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.ChartTab\");\n\n\tApp.Views.Chart.ChartTab = Backbone.View.extend( {\n\n\t\tcachedColors: [],\n\t\tel: \"#chart-view\",\n\t\tevents: {\n\t\t\t\"change [name=available_entities]\": \"onAvailableCountries\"\n\t\t},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\tthis.parentView = options.parentView;\n\t\t\tthis.$tab = this.$el.find(\"#chart-chart-tab\");\n\t\t\tthis.$svg = this.$el.find(\"svg\");\n\t\t},\n\n\t\tonChartModelChange: function() {\n\t\t\tvar chartType = App.ChartModel.get(\"chart-type\");\n\t\t\tvar needFullRender = (chartType != this.chartType);\n\n\t\t\tApp.DataModel.ready(function() {\n\t\t\t\tif (needFullRender) {\n\t\t\t\t\tthis.deactivate();\n\t\t\t\t\tthis.activate();\n\t\t\t\t} else {\n\t\t\t\t\tthis.render(this.onResize.bind(this));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t},\n\n\t\tactivate: function(callback) {\n\t\t\tApp.ChartModel.on(\"change\", this.onChartModelChange, this);\n\n\t\t\tthis.chartType = App.ChartModel.get(\"chart-type\");\n\n\t\t\tthis.$svg = $(\"svg\");\n\t\t\tthis.$svg.attr(\"class\", \"nvd3-svg\");\n\t\t\tthis.$entitiesSelect = this.$el.find( \"[name=available_entities]\" );\n\t\t\tthis.$xAxisScaleSelector = this.$el.find( \".x-axis-scale-selector\" );\n\t\t\tthis.$xAxisScale = this.$el.find( \"[name=x_axis_scale]\" );\n\t\t\tthis.$yAxisScaleSelector = this.$el.find( \".y-axis-scale-selector\" );\n\t\t\tthis.$yAxisScale = this.$el.find( \"[name=y_axis_scale]\" );\n\t\t\tthis.$reloadBtn = this.$el.find( \".reload-btn\" );\n\t\t\tvar chartTime = App.ChartModel.get(\"chart-time\");\n\n\t\t\t//show/hide scale selectors\n\t\t\tvar showXScaleSelectors = App.ChartModel.get( \"x-axis-scale-selector\" );\n\t\t\tif( showXScaleSelectors ) {\n\t\t\t\tthis.$xAxisScaleSelector.show();\n\t\t\t} else {\n\t\t\t\tthis.$xAxisScaleSelector.hide();\n\t\t\t}\n\t\t\tvar showYScaleSelectors = App.ChartModel.get( \"y-axis-scale-selector\" );\n\t\t\tif( showYScaleSelectors ) {\n\t\t\t\tthis.$yAxisScaleSelector.show();\n\t\t\t} else {\n\t\t\t\tthis.$yAxisScaleSelector.hide();\n\t\t\t}\n\n\t\t\t//refresh btn\n\t\t\tthis.$reloadBtn.on(\"click\", function(evt) {\n\t\t\t\tevt.preventDefault();\n\t\t\t\twindow.location.reload();\n\t\t\t});\n\n\t\t\tvar dimensionsString = App.ChartModel.get( \"chart-dimensions\" ),\n\t\t\t\tvalidDimensions = false;\n\n\t\t\t//check we have all dimensions necessary \n\t\t\tif( !$.isEmptyObject( dimensionsString ) ) {\n\t\t\t\tvar dimension = $.parseJSON( dimensionsString );\n\t\t\t\tvalidDimensions = App.Utils.checkValidDimensions( dimension, App.ChartModel.get( \"chart-type\" ));\n\t\t\t}\n\n\t\t\tif( !validDimensions ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.render(callback);\n\t\t},\n\n\t\tdeactivate: function() {\n\t\t\tApp.ChartModel.off(null, null, this);\n\t\t\td3.selectAll(\".nvd3\").remove();\n\t\t\tif (this.$yAxisScaleSelector)\n\t\t\t\tthis.$yAxisScaleSelector.show();\n\t\t},\n\n\t\tupdateAvailableCountries: function() {\n\t\t\tvar availableEntities = App.DataModel.get(\"availableEntities\"),\n\t\t\t\tselectedCountries = App.ChartModel.get(\"selected-countries\"),\n\t\t\t\tselectedCountriesIds = _.map(selectedCountries, function(v) { return (v)? +v.id: \"\"; });\n\n\t\t\t// Fill entity selector with all entities not currently selected\n\t\t\tthis.$entitiesSelect.empty();\n\t\t\tthis.$entitiesSelect.append(\"<option disabled selected>Select country</option>\");\n\t\t\t_.each(availableEntities, function(entity) {\n\t\t\t\tif (!_.contains(selectedCountriesIds, +entity.id)) {\n\t\t\t\t\tthis.$entitiesSelect.append(\"<option value='\" + entity.id + \"'>\" + entity.name + \"</option>\");\n\t\t\t\t}\n\t\t\t}.bind(this));\n\n\t\t\tthis.$entitiesSelect.trigger(\"chosen:updated\");\n\t\t},\n\n\t\trender: function(callback) {\n\t\t\tvar localData = App.DataModel.transformData();\n\t\t\tvar timeType = \"Year\";\n\n\t\t\tif (!localData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updateAvailableCountries();\n\n\t\t\tvar that = this;\n\n\t\t\tvar chartType = App.ChartModel.get( \"chart-type\" );\n\n\t\t\t//filter data for selected countries\n\t\t\tvar selectedCountries = App.ChartModel.get(\"selected-countries\");\n\n\t\t\tvar selectedCountriesById = [],\n\t\t\t\tselectedCountriesIds = _.map( selectedCountries, function(v) {\n\t\t\t\t\t//store\n\t\t\t\t\tselectedCountriesById[ v.id ] = v;\n\t\t\t\t\treturn +v.id;\n\t\t\t\t} );\n\n\t\t\tif( selectedCountries && selectedCountriesIds.length && !App.ChartModel.get( \"group-by-variables\" ) ) {\n\t\t\t\t//set local copy of countries color, to be able to create brighter\n\t\t\t\tvar countriesColors = [];\n\t\t\t\t_.each( localData, function( value, key, list ) {\n\t\t\t\t\t//set color while in the loop\n\t\t\t\t\tvar id = value.id.toString();\n\t\t\t\t\t//need to check for special case, when we have more variables for the same countries (the ids will be then 21-1, 22-1, etc.)\n\t\t\t\t\tif( id.indexOf( \"-\" ) > 0 ) {\n\t\t\t\t\t\tid = parseInt( id.split( \"-\" )[ 0 ], 10 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tid = parseInt( id, 10 );\n\t\t\t\t\t}\n\n\t\t\t\t\tvar country = selectedCountriesById[ id ];\n\t\t\t\t\tif( country && country.color ) {\n\t\t\t\t\t\tif( !countriesColors[ id ] ) {\n\t\t\t\t\t\t\tcountriesColors[ id ] = country.color;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//there is already color for country (multivariant dataset) - create brighter color\n\t\t\t\t\t\t\tcountriesColors[ id ] = d3.rgb( countriesColors[ id ] ).brighter( 1 ).toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue.color = countriesColors[ id ];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = that.assignColorFromCache( value );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t//TODO - nonsense? convert associative array to array, assign colors from cache\n\t\t\t\tlocalData = _.map( localData, function( value ) {\n\t\t\t\t\tvalue = that.assignColorFromCache( value );\n\t\t\t\t\treturn value;\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\tvar discreteData;\n\t\t\tif( chartType == App.ChartType.DiscreteBar ) {\n\t\t\t\tvar flattenValues = _.map( localData, function( v ) {\n\t\t\t\t\tif( v && v.color ) {\n\t\t\t\t\t\tv.values[ 0 ].color = v.color;\n\t\t\t\t\t}\n\t\t\t\t\treturn v.values[0];\n\t\t\t\t} );\n\t\t\t\tdiscreteData = [{ key: \"variable\", values: flattenValues }];\n\t\t\t\tlocalData = discreteData;\n\t\t\t}\n\n\t\t\t//filter by chart time\n\t\t\tvar chartTime = App.ChartModel.get( \"chart-time\" );\n\t\t\tif( chartTime && chartTime.length == 2 ) {\n\t\t\t\t\n\t\t\t\tvar timeFrom = chartTime[ 0 ],\n\t\t\t\t\ttimeTo = chartTime[ 1 ];\n\t\t\t\t\n\t\t\t\t_.each( localData, function( singleData, key, list ) {\n\t\t\t\t\tvar values = _.clone( singleData.values );\n\t\t\t\t\tvalues = _.filter( values, function( value ) {\n\t\t\t\t\t\tif (_.isObject(value.time)) {\n\t\t\t\t\t\t\treturn _.every(value.time, function(val, key) {\n\t\t\t\t\t\t\t\treturn ( val >= timeFrom && val <= timeTo );\n\t\t\t\t\t\t\t});\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn ( value.x >= timeFrom && value.x <= timeTo );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\tsingleData.values = values;\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// For stacked area chart, the order of the series matters. For other chart\n\t\t\t// types we sort them alphabetically.\n\t\t\tif (chartType == App.ChartType.StackedArea) {\n\t\t\t} else {\n\t\t\t\tlocalData = _.sortBy(localData, function(obj) { return obj.key; });\n\t\t\t}\n\n\t\t\t//get axis configs\n\t\t\tvar xAxis = App.ChartModel.get( \"x-axis\" ),\n\t\t\t\tyAxis = App.ChartModel.get( \"y-axis\" ),\n\t\t\t\txAxisPrefix = ( xAxis[ \"axis-prefix\" ] || \"\" ),\n\t\t\t\txAxisSuffix = ( xAxis[ \"axis-suffix\" ] || \"\" ),\n\t\t\t\tyAxisPrefix = ( yAxis[ \"axis-prefix\" ] || \"\" ),\n\t\t\t\tyAxisSuffix = ( yAxis[ \"axis-suffix\" ] || \"\" ),\n\t\t\t\txAxisLabelDistance = ( +xAxis[ \"axis-label-distance\" ] || 0 ),\n\t\t\t\tyAxisLabelDistance = ( +yAxis[ \"axis-label-distance\" ] || 0 ),\n\t\t\t\txAxisMin = ( xAxis[ \"axis-min\" ] || null ),\n\t\t\t\txAxisMax = ( xAxis[ \"axis-max\" ] || null ),\n\t\t\t\tyAxisMin = ( yAxis[ \"axis-min\" ] || 0 ),\n\t\t\t\tyAxisMax = ( yAxis[ \"axis-max\" ] || null ),\n\t\t\t\txAxisScale = ( xAxis[ \"axis-scale\" ] || \"linear\" ),\n\t\t\t\tyAxisScale = ( yAxis[ \"axis-scale\" ] || \"linear\" ),\n\t\t\t\txAxisFormat = ( xAxis[ \"axis-format\" ] || 0 ),\n\t\t\t\tyAxisFormat = ( yAxis[ \"axis-format\" ] || 0 );\n\n\t\t\t//setting up nvd3 chart\n\t\t\tnv.addGraph(function() {\n\t\t\t\tvar chartOptions = {\n\t\t\t\t\tmargin: { top:0, left:50, right:30, bottom:0 },// App.ChartModel.get( \"margins\" ),\n\t\t\t\t\tshowLegend: false\n\t\t\t\t};\n\n\t\t\t\t//line type\n\t\t\t\tvar lineType = App.ChartModel.get( \"line-type\" );\n\t\t\t\tif( lineType == App.LineType.UnjoinedIfMissing ) {\n\t\t\t\t\t//chartOptions.defined = function( d ) { return d.y == 0; };\n\t\t\t\t}\n\t\t\t\tif( lineType == App.LineType.WithDots || lineType == App.LineType.DashedIfMissing ) {\n\t\t\t\t\tthat.$el.addClass( \"line-dots\" );\n\t\t\t\t} else {\n\t\t\t\t\tthat.$el.removeClass( \"line-dots\" );\n\t\t\t\t}\n\n\t\t\t\t//depending on chart type create chart\n\t\t\t\tif( chartType == App.ChartType.LineChart ) {\n\t\t\t\t\tthat.chart = nv.models.lineChart().options( chartOptions );\n\n\t\t\t\t} else if( chartType == App.ChartType.ScatterPlot ) {\n\t\t\t\t\tvar points = that.scatterBubbleSize();\n\t\t\t\t\tthat.chart = nv.models.scatterChart().options( chartOptions ).pointRange( points ).showDistX( true ).showDistY( true );\n\n\t\t\t\t} else if( chartType == App.ChartType.StackedArea ) {\n\t\t\t\t\t//stacked area chart\n\t\t\t\t\t//we need to make sure we have as much data as necessary\n\t\t\t\t\tif( localData.length ) {\n\t\t\t\t\t\tvar baseSeries = localData[0];\n\t\t\t\t\t\t_.each( localData, function( serie, i ) {\n\t\t\t\t\t\t\tif( i > 0 ) {\n\t\t\t\t\t\t\t\t//make sure we have values for given series\n\t\t\t\t\t\t\t\tif( serie.values && !serie.values.length ) {\n\t\t\t\t\t\t\t\t\t//clone base series\n\t\t\t\t\t\t\t\t\tvar copyValues = [];\n\t\t\t\t\t\t\t\t\t$.extend(true, copyValues, baseSeries.values);\n\t\t\t\t\t\t\t\t\t//nullify values\n\t\t\t\t\t\t\t\t\t_.each( copyValues, function( v, i) {\n\t\t\t\t\t\t\t\t\t\tv.y = 0;\n\t\t\t\t\t\t\t\t\t\tv.fake = \"true\";\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tserie.values = copyValues;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\tchartOptions.showTotalInTooltip = true;\n\n\t\t\t\t\tthat.chart = nv.models.stackedAreaChart()\n\t\t\t\t\t\t.options(chartOptions)\n\t\t\t\t\t\t.controlOptions([\"Stacked\", \"Expanded\"])\n\t\t\t\t\t\t.controlLabels({\n\t\t\t\t\t\t\t\"stacked\": \"Absolute\",\n\t\t\t\t\t\t\t\"expanded\": \"Relative\"\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.useInteractiveGuideline(true)\n\t\t\t\t\t\t.x(function(d) { return d.x; })\n\t\t\t\t\t\t.y(function(d) { return d.y; });\n\n\t\t\t\t\tif (App.ChartModel.get(\"currentStackMode\") == \"relative\")\n\t\t\t\t\t\tthat.chart.style(\"expand\");\t\t\t\n\n\t\t\t\t} else if( chartType == App.ChartType.MultiBar || chartType == App.ChartType.HorizontalMultiBar ) {\n\n\t\t\t\t\t//multibar chart\n\t\t\t\t\t//we need to make sure we have as much data as necessary\n\t\t\t\t\tvar allTimes = [],\n\t\t\t\t\t\t//store values by [entity][time]\n\t\t\t\t\t\tvaluesCheck = [];\n\n\t\t\t\t\t//extract all times\n\t\t\t\t\t_.each( localData, function( v, i ) {\n\t\t\t\t\t\tvar entityData = [],\n\t\t\t\t\t\t\ttimes = v.values.map( function( v2, i ) {\n\t\t\t\t\t\t\t\tentityData[ v2.x ] = true;\n\t\t\t\t\t\t\t\treturn v2.x;\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\tvaluesCheck[ v.id ] = entityData;\n\t\t\t\t\t\tallTimes = allTimes.concat( times );\n\t\t\t\t\t} );\n\n\t\t\t\t\tallTimes = _.uniq( allTimes );\n\t\t\t\t\tallTimes = _.sortBy( allTimes );\n\t\t\t\t\t\n\t\t\t\t\tif( localData.length ) {\n\t\t\t\t\t\t_.each( localData, function( serie, serieIndex ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//make sure we have values for given series\n\t\t\t\t\t\t\t_.each( allTimes, function( time, timeIndex ) {\n\t\t\t\t\t\t\t\tif( valuesCheck[ serie.id ] && !valuesCheck[ serie.id ][ time ] ) {\n\t\t\t\t\t\t\t\t\t//time doesn't existig for given entity, insert zero value\n\t\t\t\t\t\t\t\t\tvar zeroObj = {\n\t\t\t\t\t\t\t\t\t\t\"key\": serie.key,\n\t\t\t\t\t\t\t\t\t\t\"serie\": serieIndex,\n\t\t\t\t\t\t\t\t\t\t\"time\": time,\n\t\t\t\t\t\t\t\t\t\t\"x\": time,\n\t\t\t\t\t\t\t\t\t\t\"y\": 0,\n\t\t\t\t\t\t\t\t\t\t\"fake\": true\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tserie.values.splice( timeIndex, 0, zeroObj );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chartType == App.ChartType.MultiBar) {\n\t\t\t\t\t\tthat.chart = nv.models.multiBarChart().options(chartOptions);\t\t\t\t\t\n\t\t\t\t\t} else if( App.ChartType.HorizontalMultiBar ) {\n\t\t\t\t\t\tthat.chart = nv.models.multiBarHorizontalChart().options(chartOptions);\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t} else if( chartType == App.ChartType.DiscreteBar ) {\n\n\t\t\t\t\tchartOptions.showValues = true;\n\n\t\t\t\t\tthat.chart = nv.models.discreteBarChart()\n\t\t\t\t\t\t.x( function( d ) { return d.x; } )\n\t\t\t\t\t\t.y( function( d ) { return d.y; } )\n\t\t\t\t\t\t.options( chartOptions );\n\n\t\t\t\t}\n\n\t\t\t\tthat.chart.dispatch.on(\"renderEnd\", function(state) {\n\t\t\t\t\t$(window).trigger('chart-loaded');\n\n\t\t\t\t\t/* HACK (Mispy): Hijack nvd3 mode switch for stacked area charts. */\n\t\t\t\t\tif (chartType == App.ChartType.StackedArea) {\n\t\t\t\t\t\td3.selectAll(\".nv-controlsWrap .nv-series\").on(\"click\", function(opt) {\n\t\t\t\t\t\t\tif (opt.key == \"Relative\") {\n\t\t\t\t\t\t\t\tApp.ChartModel.set(\"currentStackMode\", \"relative\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tApp.ChartModel.set(\"currentStackMode\", \"absolute\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\t// Stop the tooltip from overlapping the chart controls\n\t\t\t\t\t\td3.selectAll(\"svg\").on(\"mousemove.stackedarea\", function() {\n\t\t\t\t\t\t\tvar $target = $(d3.event.target);\n\t\t\t\t\t\t\tif (!$target.is(\"rect, path\") || $target.closest(\".nv-custom-legend\").length)\n\t\t\t\t\t\t\t\tthat.chart.interactiveLayer.tooltip.hidden(true);\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\t\t\t\t\n\t\n\t\t\t\tthat.chart.dispatch.on(\"stateChange\", function() {\n\t\t\t\t\t/* HACK (Mispy): Ensure stacked area charts maintain the correct dimensions on \n\t\t\t\t\t * transition between stacked and expanded modes. It cannot be done on renderEnd\n\t\t\t\t\t * or stateChange because the delay causes the chart to jump; overriding update\n\t\t\t\t\t * seems to be the only way to get it to synchronously flow into resizing. It must\n\t\t\t\t\t * be re-overridden in renderEnd because the nvd3 chart render function resets it. Note\n\t\t\t\t\t * that stacked area charts also pay no attention to the margin setting. */\n\t\t\t\t\tvar origUpdate = that.chart.update;\n\t\t\t\t\tthat.chart.update = function() {\n\t\t\t\t\t\torigUpdate.call(that.chart);\n\t\t\t\t\t\tthat.onResize();\n\t\t\t\t\t};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t});\n\t\n\t\t\t\t//fixed probably a bug in nvd3 with previous tooltip not being removed\n\t\t\t\td3.select( \".xy-tooltip\" ).remove();\n\n\t\t\t\tthat.chart.xAxis\n\t\t\t\t\t.axisLabel( xAxis[ \"axis-label\" ] )\n\t\t\t\t\t//.staggerLabels( true )\n\t\t\t\t\t.axisLabelDistance( xAxisLabelDistance )\n\t\t\t\t\t.tickFormat( function(d) {\n\t\t\t\t\t\tif (chartType != App.ChartType.ScatterPlot) {\n\t\t\t\t\t\t\t//x axis has time information\n\t\t\t\t\t\t\treturn App.Utils.formatTimeLabel( timeType, d, xAxisPrefix, xAxisSuffix, xAxisFormat );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//is scatter plot, x-axis has some other information\n\t\t\t\t\t\t\treturn xAxisPrefix + d3.format( \",\" )( App.Utils.formatValue( d, xAxisFormat ) ) + xAxisSuffix;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t//get extend\n\t\t\t\tvar allValues = [];\n\t\t\t\t_.each( localData, function( v, i ) {\n\t\t\t\t\tif( v.values ) {\n\t\t\t\t\t\tallValues = allValues.concat( v.values );\n\t\t\t\t\t} else if( $.isArray( v ) ){\n\t\t\t\t\t\t//special case for discrete bar chart\n\t\t\t\t\t\tallValues = v;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\t//domain setup\n\t\t\t\tvar xDomain = d3.extent( allValues.map( function( d ) { return d.x; } ) ),\n\t\t\t\t\tyDomain = d3.extent( allValues.map( function( d ) { return d.y; } ) ),\n\t\t\t\t\tisClamped = false;\n\t\t\t\t//console.log( \"chart.stacked.style()\", that.chart.stacked.style() );\n\n\t\t\t\tif( xAxisMin && !isNaN( xAxisMin ) ) {\n\t\t\t\t\txDomain[ 0 ] = xAxisMin;\n\t\t\t\t\tisClamped = true;\n\t\t\t\t}\n\t\t\t\tif( xAxisMax && !isNaN( xAxisMax ) ) {\n\t\t\t\t\txDomain[ 1 ] = xAxisMax;\n\t\t\t\t\tisClamped = true;\n\t\t\t\t}\n\t\t\t\tif( yAxisMin && !isNaN( yAxisMin ) && (yAxisMin > 0 || yAxisScale != \"log\")) {\n\t\t\t\t\tyDomain[ 0 ] = yAxisMin;\n\t\t\t\t\tisClamped = true;\n\t\t\t\t} else {\n\t\t\t\t\t//default is zero (don't do it for stack bar chart or log scale, messes up things)\n\t\t\t\t\tif( chartType != App.ChartType.StackedArea && yAxisScale != \"log\" ) {\n\t\t\t\t\t\tyDomain[ 0 ] = 0;\n\t\t\t\t\t\tisClamped = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( yAxisMax && !isNaN( yAxisMax ) ) {\n\t\t\t\t\tyDomain[ 1 ] = yAxisMax;\n\t\t\t\t\tisClamped = true;\n\t\t\t\t}\n\n\t\t\t\t//manually clamp values\n\t\t\t\tif( isClamped ) {\n\t\t\t\t\tif( chartType !== \"4\" && chartType !== \"5\" && chartType !== \"6\" ) {\n\t\t\t\t\t\t//version which makes sure min/max values are present, but will display values outside of the range\n\t\t\t\t\t\tthat.chart.forceX( xDomain );\n\t\t\t\t\t\tthat.chart.forceY( yDomain );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//set scales, multibar chart\n\t\t\t\tif( yAxisScale === \"linear\" ) {\n\t\t\t\t\tthat.chart.yScale( d3.scale.linear() );\n\t\t\t\t} else if( yAxisScale === \"log\" ) {\n\t\t\t\t\tthat.chart.yScale( d3.scale.log() );\n\t\t\t\t}\n\n\t\t\t\tif( chartType === \"4\" || chartType === \"5\" ) {\n\t\t\t\t\t//for multibar chart, x axis has ordinal scale, so need to setup domain properly\n\t\t\t\t\t//that.chart.xDomain( d3.range(xDomain[0], xDomain[1] + 1) );\n\t\t\t\t\tthat.chart.xDomain( allTimes );\n\t\t\t\t}\n\n\t\t\t\tthat.chart.yAxis\n\t\t\t\t\t.axisLabel( yAxis[ \"axis-label\" ] )\n\t\t\t\t\t.axisLabelDistance( yAxisLabelDistance )\n\t\t\t\t\t.tickFormat( function(d) { return yAxisPrefix + d3.format( \",\" )( App.Utils.formatValue( d, yAxisFormat ) ) + yAxisSuffix; })\n\t\t\t\t\t.showMaxMin(false);\n\n\t\t\t\t//scatter plots need more ticks\n\t\t\t\tif( chartType === App.ChartType.ScatterPlot ) {\n\t\t\t\t\t//hardcode\n\t\t\t\t\tthat.chart.xAxis.ticks( 7 );\n\t\t\t\t\tthat.chart.yAxis.ticks( 7 );\n\t\t\t\t}\n\n\t\t\t\twindow.localData = localData;\n\n\t\t\t\tvar displayData = localData;\n\t\t\t\tif (chartType == App.ChartType.LineChart && (lineType == App.LineType.DashedIfMissing))// || lineType == App.LineType.UnjoinedIfMissing))\n\t\t\t\t\tdisplayData = that.splitSeriesByMissing(localData);\n\t\t\t\twindow.displayData = displayData;\n\t\t\t\tthat.svgSelection = d3.select( that.$svg.selector )\n\t\t\t\t\t.datum(displayData)\n\t\t\t\t\t.call( that.chart );\n\n\t\t\t\tif (chartType == App.ChartType.StackedArea)\n\t\t\t\t\tthat.chart.interactiveLayer.tooltip.contentGenerator(owid.contentGenerator);\n\t\t\t\telse\n\t\t\t\t\tthat.chart.tooltip.contentGenerator(owid.contentGenerator);\n\t\t\t\t\n\t\t\t\t//set legend\n\t\t\t\tif (!App.ChartModel.get(\"hide-legend\")) {\n\t\t\t\t\t//make sure wrapper is visible\n\t\t\t\t\tthat.$svg.find( \"> .nvd3.nv-custom-legend\" ).show();\n\t\t\t\t\tthat.legend = new App.Views.Chart.Legend( that.chart.legend ).vers( \"owd\" );\n\t\t\t\t\tthat.legend.dispatch.on(\"addEntity\", function() {\n\t\t\t\t\t\tif (that.$entitiesSelect.data(\"chosen\")) {\n\t\t\t\t\t\t\tthat.$entitiesSelect.data(\"chosen\").active_field = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//trigger open the chosen drop down\n\t\t\t\t\t\tthat.$entitiesSelect.trigger(\"chosen:open\");\n\t\t\t\t\t} );\n\t\t\t\t\tthat.svgSelection.call( that.legend );\n\t\t\t\t\t//put legend above chart\n\n\t\t\t\t\t//if stacked area chart\n\t\t\t\t\tif (chartType == App.ChartType.StackedArea) {\n\t\t\t\t\t\tthat.chart.stacked.dispatch.on(\"areaMouseover\", function(evt) {\n\t\t\t\t\t\t\tthat.legend.highlightPoint(evt);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthat.chart.stacked.dispatch.on(\"areaMouseout\", function(evt) {\n\t\t\t\t\t\t\tthat.legend.clearHighlight();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//no legend, remove what might have previously been there\n\t\t\t\t\tthat.$svg.find( \"> .nvd3.nv-custom-legend\" ).hide();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar dimensions = JSON.parse(App.ChartModel.get(\"chart-dimensions\"));\n\n\t\t\t\tif (chartType == App.ChartType.ScatterPlot) {\n\t\t\t\t\t//need to have own showDist implementation, cause there's a bug in nvd3\n\t\t\t\t\tthat.scatterDist();\n\t\t\t\t}\n\n\t\t\t\t//if y axis has zero, display solid line\n\t\t\t\tvar $pathDomain = $( \".nvd3 .nv-axis.nv-x path.domain\" );\n\t\t\t\tif( yDomain[ 0 ] === 0 ) {\n\t\t\t\t\t$pathDomain.css( \"stroke-opacity\", \"1\" );\n\t\t\t\t} else {\n\t\t\t\t\t$pathDomain.css( \"stroke-opacity\", \"0\" );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar chartDimensionsString = App.ChartModel.get( \"chart-dimensions\" );\n\t\t\t\tif( chartDimensionsString.indexOf( '\"property\":\"color\"' ) === -1 ) {\n\t\t\t\t\t//check if string does not contain \"property\":\"color\"\n\t\t\t\t\tthat.cacheColors( localData );\n\t\t\t\t}\n\n\t\t\t\twindow.chart = that.chart;\n\t\t\t\tthat.onResize();\n\t\t\t\tif (callback) callback();\n\t\t\t});\n\n\t\t\tthis.localData = localData;\n\t\t},\n\n\t\tshow: function() {\n\t\t\tthis.$el.show();\n\t\t},\n\n\t\thide: function() {\n\t\t\tthis.$el.hide();\n\t\t},\n\n\t\tscatterDist: function() {\n\t\t\tvar that = this,\n\t\t\t\tmargins = App.ChartModel.get( \"margins\" ),\n\t\t\t\tnvDistrX = $( \".nv-distributionX\" ).offset().top,\n\t\t\t\tsvgSelection = d3.select( \"svg\" );\n\n\t\t\tthat.chart.scatter.dispatch.on('elementMouseover.tooltip', function(evt) {\n\t\t\t\tvar svgOffset = that.$svg.offset(),\n\t\t\t\t\tsvgHeight = that.$svg.height();\n\t\t\t\tsvgSelection.select('.nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex)\n\t\t\t\t\t.attr('y1', evt.pos.top - nvDistrX );\n\t\t\t\tsvgSelection.select('.nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex)\n\t\t\t\t\t.attr('x2', evt.pos.left - svgOffset.left - margins.left );\n\t\t\t\tvar position = {left: d3.event.clientX, top: d3.event.clientY };\n\t\t\t\tthat.chart.tooltip.position(position).data(evt).hidden(false);\n\t\t\t});\n\t\t},\n\n\t\tsplitSeriesByMissing: function(localData) {\n\t\t\tvar lineType = App.ChartModel.get(\"line-type\"),\n\t\t\t\tlineTolerance = parseInt(App.ChartModel.get(\"line-tolerance\")) || 1,\n\t\t\t\tnewData = [];\n\n\t\t\t_.each(localData, function(series) {\n\t\t\t\tvar currentSeries = null;\n\t\t\t\tvar currentMissing = null;\n\n\t\t\t\t_.each(series.values, function(d) {\n\t\t\t\t\tvar isMissing = (d.gapYearsToNext && d.gapYearsToNext > lineTolerance);\n\t\t\t\t\tif (isMissing !== currentMissing) {\n\t\t\t\t\t\tif (currentSeries !== null) {\n\t\t\t\t\t\t\t// There's a single overlapping value to keep the lines joined\n\t\t\t\t\t\t\tcurrentSeries.values.push(d);\n\t\t\t\t\t\t\tnewData.push(currentSeries);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentSeries = _.extend({}, series, { values: [] });\n\t\t\t\t\t\tif (isMissing && lineType == App.LineType.DashedIfMissing)\n\t\t\t\t\t\t\tcurrentSeries.classed = 'dashed';\n\t\t\t\t\t\telse if (isMissing)\n\t\t\t\t\t\t\tcurrentSeries.classed = 'unstroked';\n\t\t\t\t\t\tcurrentMissing = isMissing;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentSeries.values.push(d);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// HACK (Mispy): Mutate the keys so nvd3 actually draws the new series.\n\t\t\t// Kludgy but necessary for now.\n\t\t\tvar keys = {};\n\t\t\t_.each(newData, function(series, i) {\n\t\t\t\tseries.origKey = series.key;\n\t\t\t\tif (keys[series.key]) {\n\t\t\t\t\tseries.key = series.key + i;\n\t\t\t\t\tseries.id = \"copy-\"+series.id;\n\t\t\t\t\tseries.isCopy = true;\n\t\t\t\t} else\n\t\t\t\t\tkeys[series.key] = true;\n\t\t\t});\n\n\t\t\treturn newData;\n\t\t},\n\n\t\tscatterBubbleSize: function() {\n\t\t\t//set size of the bubbles depending on browser width\n\t\t\tvar browserWidth = $( window ).width(),\n\t\t\t\tbrowserCoef = Math.max( 1, browserWidth / 1100 ),\n\t\t\t\tpointMin = 100 * Math.pow( browserCoef, 2 ),\n\t\t\t\tpointMax = 1000 * Math.pow( browserCoef, 2 );\n\t\t\treturn [ pointMin, pointMax ];\n\t\t},\n\n\t\tcheckStackedAxis: function() {\n\n\t\t\t//setting yAxisMax breaks expanded stacked chart, need to check manually\n\t\t\tvar stackedStyle = this.chart.stacked.style(),\n\t\t\t\tyAxis = App.ChartModel.get( \"y-axis\" ),\n\t\t\t\tyAxisMin = ( yAxis[ \"axis-min\" ] || 0 ),\n\t\t\t\tyAxisMax = ( yAxis[ \"axis-max\" ] || null ),\n\t\t\t\tyDomain = [ yAxisMin, yAxisMax ];\n\t\t\tif( yAxisMax ) {\n\t\t\t\t//chart has set yAxis to max, depending on stacked style set max\n\t\t\t\tif( stackedStyle === \"expand\" ) {\n\t\t\t\t\tyDomain = [ 0, 1 ];\n\t\t\t\t}\n\t\t\t\tthis.chart.yDomain( yDomain );\n\t\t\t}\n\t\t},\n\n\n\t\tonAvailableCountries: function(evt) {\n\t\t\tvar $select = $( evt.currentTarget ),\n\t\t\t\tval = $select.val(),\n\t\t\t\t$option = $select.find( \"[value=\" + val + \"]\" ),\n\t\t\t\ttext = $option.text();\n\n\t\t\tif( !App.ChartModel.get( \"group-by-variables\" ) && App.ChartModel.get( \"add-country-mode\" ) === \"add-country\" ) {\n\t\t\t\tApp.ChartModel.addSelectedCountry( { id: $select.val(), name: text } );\n\t\t\t} else {\n\t\t\t\tApp.ChartModel.replaceSelectedCountry( { id: $select.val(), name: text } );\n\t\t\t}\n\n\t\t\t//double check if we don't have full selection of countries\n\t\t\tvar entitiesCollection = {},\n\t\t\t\tformConfig = App.ChartModel.get( \"form-config\" );\n\t\t\tif( formConfig && formConfig[ \"entities-collection\" ] ) {\n\t\t\t\tvar selectedCountriesIds = _.keys( App.ChartModel.get( \"selected-countries\" ) );\n\t\t\t\tif( selectedCountriesIds.length == formConfig[ \"entities-collection\" ].length ) {\n\t\t\t\t\tApp.ChartModel.set( \"selected-countries\", [], {silent:true} );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tcacheColors: function(data) {\n\t\t\tif( !this.cachedColors.length ) {\n\t\t\t\tvar that = this;\n\t\t\t\t_.each( data, function( v, i ) {\n\t\t\t\t\tthat.cachedColors[ v.id ] = v.color;\n\t\t\t\t} );\n\t\t\t}\n\t\t},\n\n\t\tassignColorFromCache: function( value ) {\n\t\t\tthis.cachedColors = this.cachedColors || {};\n\t\t\tif( this.cachedColors.length ) {\n\t\t\t\t//assing color frome cache\n\t\t\t\tif( this.cachedColors[ value.id ] ) {\n\t\t\t\t\tvalue.color = this.cachedColors[ value.id ];\n\t\t\t\t} else {\n\t\t\t\t\tvar randomColor = App.Utils.getRandomColor();\n\t\t\t\t\tvalue.color = randomColor;\n\t\t\t\t\tthis.cachedColors[ value.id ] = randomColor;\n\t\t\t\t}\n\t\t\t} else if (!value.color && App.ChartModel.get(\"chart-type\") == App.ChartType.LineChart) {\n\t\t\t\tthis.colorScale = this.colorScale || nv.utils.getColor(d3.scale.category20().range());\n\t\t\t\tthis.colorIndex = this.colorIndex || 0;\n\t\t\t\tvalue.color = this.colorScale(this.colorIndex += 1);\t\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\t\tonResize: function(callback) {\n\t\t\tif (_.isEmpty(this.localData)) {\n\t\t\t\tif (callback) callback();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.legend) {\n\t\t\t\tthis.svgSelection.call(this.legend);\n\t\t\t}\n\n\t\t\t//compute how much space for chart\n\t\t\tvar margins = App.ChartModel.get(\"margins\"),\n\t\t\t\tsvg = d3.select(this.$svg[0]),\n\t\t\t\tsvgBounds = svg.node().getBoundingClientRect(),\n\t\t\t\ttabBounds = $(\".tab-pane.active\").get(0).getBoundingClientRect(),\n\t\t\t\tchartOffsetY = tabBounds.top - svgBounds.top + parseFloat(margins.top) + 10,\n\t\t\t\tchartOffsetX = parseFloat(margins.left),\n\t\t\t\t// MISPY: The constant modifiers here are to account for nvd3 not entirely matching our specified dimensions\n\t\t\t\tchartHeight = tabBounds.height - parseFloat(margins.bottom) - parseFloat(margins.top) - 20 - 10,\n\t\t\t\tchartWidth = tabBounds.width - parseFloat(margins.left) - parseFloat(margins.right) + 60,\n\t\t\t\tchartType = App.ChartModel.get(\"chart-type\");\n\n\t\t\t// Account for and position legend\n\t\t\tif (this.legend) {\n\t\t\t\tvar legendMargins = this.legend.margin();\n\t\t\t\tthis.translateString = \"translate(\" + legendMargins.left + \" ,\" + chartOffsetY + \")\";\n\t\t\t\tsvg.select(\".nvd3.nv-custom-legend\").attr(\"transform\", this.translateString);\n\n\t\t\t\tchartOffsetY += this.legend.height();\n\t\t\t\tchartHeight -= this.legend.height();\n\t\t\t}\n\n\t\t\tif (App.ChartModel.get(\"x-axis\")[\"axis-label\"]) {\n\t\t\t\tchartHeight -= 30;\n\t\t\t}\n\n\t\t\t// MISPY: These charts need a special offset because nvd3 doesn't seem\n\t\t\t// to count the controls as part of the width and height.\n\t\t\tif (chartType == App.ChartType.StackedArea || chartType == App.ChartType.MultiBar || chartType == App.ChartType.HorizontalMultiBar) {\n\t\t\t\tchartOffsetY += 20;\n\t\t\t\tif (chartType != App.ChartType.StackedArea)\n\t\t\t\t\tchartHeight -= 20;\n\t\t\t}\n\n\t\t\t// Make sure we actually have enough room for the chart to be visible!\n\t\t\tvar minHeight = 150;\n\t\t\tif (chartHeight < minHeight) {\n\t\t\t\tvar $wrapper = App.ChartView.$(\".chart-wrapper-inner\");\n\t\t\t\t$wrapper.css(\"height\", $wrapper.height() + (minHeight-chartHeight) + 10 + \"px\");\n\t\t\t\tApp.ChartView.onResize(callback, true);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Inform nvd3 of the situation\n\t\t\tthis.chart.width(chartWidth);\n\t\t\tthis.chart.height(chartHeight);\n\t\t\tthis.chart.update();\n\n\t\t\tvar wrap = svg.select(\".nvd3.nv-wrap\");\n\t\t\tthis.translateString = \"translate(\" + chartOffsetX + \",\" + chartOffsetY + \")\";\n\t\t\twrap.attr(\"transform\", this.translateString);\n\n\t\t\t// Move controls up for multibar chart\n\t\t\tif (chartType == App.ChartType.MultiBar || chartType == App.ChartType.HorizontalMultiBar) {\n\t\t\t\td3.select( \".nv-controlsWrap\" ).attr( \"transform\", \"translate(0,-30)\" );\n\t\t\t}\n\n\t\t\t//position scale dropdowns - TODO - isn't there a better way then with timeout?\n\t\t\tsetTimeout(function() {\n\t\t\t\tvar chartRect = svg.select(\".nvd3 g > rect\"),\n\t\t\t\t\tchartBounds = chartRect.node().getBoundingClientRect(),\n\t\t\t\t\toffsetX = chartBounds.left - svgBounds.left,\n\t\t\t\t\toffsetY = 0;\n\n\t\t\t\tthis.$xAxisScaleSelector.css({ left: offsetX + chartBounds.width, top: offsetY + chartBounds.height });\n\t\t\t\tthis.$yAxisScaleSelector.css({ left: offsetX, top: offsetY });\n\t\t\t}.bind(this), 250);\n\n\t\t\tif (_.isFunction(callback)) callback();\n\t\t}\t\t\t\t\t\n\t} );\n\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.DataTab\");\n\n\tApp.Views.Chart.DataTab = Backbone.View.extend({\n\t\tel: \"#chart-view #data-chart-tab\",\n\t\tevents: {},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.parentView = options.parentView;\n\t\t\tthis.dispatcher = options.dispatcher;\n\n\t\t\tthis.$tab = this.$el;\n\t\t\tthis.$downloadBtn = this.$el.find(\".download-data-btn\");\n\t\t\tthis.$downloadFullBtn = this.$el.find(\".download-full-btn\");\n\t\t\tthis.$dataTable = this.$el.find(\".data-table\");\n\t\t},\n\n\t\tactivate: function(callback) {\n\t\t\tthis.render(callback);\n\t\t\tApp.ChartModel.on(\"change\", this.render.bind(this), this);\n\t\t},\n\n\t\tdeactivate: function() {\n\t\t\tApp.ChartModel.off(null, null, this);\n\t\t\tthis.$dataTable.empty();\n\t\t},\n\n\t\trender: function(callback) {\n\t\t\tvar params = owid.getQueryParams();\n\t\t\tdelete(params.tab);\n\t\t\tvar queryStr = owid.queryParamsToStr(params),\n\t\t\t\tbaseUrl = Global.rootUrl + \"/\" + App.ChartModel.get(\"chart-slug\"),\n\t\t\t\tcsvUrl = baseUrl + \".csv\" + queryStr;\n\n\t\t\tthis.$downloadBtn.attr(\"href\", csvUrl);\n\t\t\tthis.$downloadFullBtn.attr(\"href\", baseUrl + \".csv\" + \"?country=ALL\");\n\n\t\t\t$.get(csvUrl)\n\t\t\t\t.done(function(csv) {\n\t\t\t\t\tPapa.parse(csv, {\n\t\t\t\t\t\tcomplete: function(results) {\n\t\t\t\t\t\t\tvar rowHtml = \"\";\n\t\t\t\t\t\t\t_.each(results.data, function(row) {\n\t\t\t\t\t\t\t\trowHtml += \"<tr>\";\n\t\t\t\t\t\t\t\t_.each(row, function(value) {\n\t\t\t\t\t\t\t\t\trowHtml += \"<td>\" + value + \"</td>\";\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\trowHtml += \"</tr>\";\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tthis.$dataTable.html(rowHtml);\n\t\t\t\t\t\t\tif (_.isFunction(callback)) callback();\n\t\t\t\t\t\t}.bind(this)\n\t\t\t\t\t});\n\t\t\t\t}.bind(this))\n\t\t\t\t.fail(function(err) {\n\t\t\t\t\tApp.ChartView.handleError(err);\n\t\t\t\t});\n\t\t},\n\t});\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.SourcesTab\");\n\n\tApp.Views.Chart.SourcesTab = Backbone.View.extend( {\n\t\tel: \"#chart-view\",\n\t\tevents: {},\n\n\t\tinitialize: function(options) {\n\t\t\tthis.parentView = options.parentView;\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\tthis.$tab = this.$el.find(\"#sources-chart-tab\");\n\t\t},\n\n\t\tactivate: function(callback) {\n\t\t\tthis.render();\n\n\t\t\tApp.ChartModel.on(\"change\", function() {\n\t\t\t\tApp.DataModel.ready(this.render.bind(this));\t\t\t\t\t\t\t\t\n\t\t\t}.bind(this), this);\n\n\t\t\tif (callback) callback();\n\t\t},\n\n\t\tdeactivate: function() {\n\t\t\tApp.ChartModel.off(null, null, this);\n\t\t\tthis.$tab.empty();\n\t\t},\n\n\t\trender: function() {\n\t\t\tvar sources = App.DataModel.transformDataForSources(),\n\t\t\t\ttabHtml = \"\";\n\n\t\t\t_.each(sources, function(source) {\n\t\t\t\ttabHtml += source.description;\n\t\t\t});\n\n\t\t\tthis.$tab.html(tabHtml);\n\t\t},\n\t});\n})();",";(function() {\t\n\t\"use strict\";\n\n\towid.namespace(\"App.Views.Chart.Map.MapControls\");\n\n\tApp.Views.Chart.Map.MapControls = Backbone.View.extend({\n\t\tel: \"#map-chart-tab .map-controls-header\",\n\t\tevents: {\n\t\t\t\"input .target-year-control input\": \"onTargetYearInput\",\n\t\t\t\"change .target-year-control input\": \"onTargetYearChange\",\n\t\t\t\"click .region-control li\": \"onRegionClick\",\n\t\t\t\"click .settings-control input\": \"onSettingsInput\",\n\t\t\t\"click .color-blind-control\": \"onColorBlindClick\",\n\t\t},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\n\t\t\tvar mapConfig = App.ChartModel.get( \"map-config\" );\n\t\t\t\n\t\t\t//year slider\n\t\t\tthis.$targetYearControl = this.$el.find( \".target-year-control\" );\n\t\t\tthis.$targetYearLabel = this.$targetYearControl.find( \".target-year-label\" );\n\t\t\tthis.$targetYearInput = this.$targetYearControl.find( \"input\" );\n\t\t\t\n\t\t\t//region selector\n\t\t\tthis.$regionControl = this.$el.find( \".region-control\" );\n\t\t\tthis.$regionControlLabel = this.$regionControl.find( \".region-label\" );\n\t\t\tthis.$regionControlLis = this.$regionControl.find( \"li\" );\n\n\t\t\t//settings-control selector\n\t\t\tthis.$settingsControl = this.$el.find( \".settings-control\" );\n\n\t\t\t//color blind control selector\n\t\t\tthis.$colorBlindControl = this.$el.find( \".color-blind-control\" );\n\t\t\t//cache original\n\t\t\tthis.originalColorSchemeName = mapConfig.colorSchemeName;\n\n\t\t\tApp.ChartModel.on( \"change\", this.onChartModelChange, this );\n\t\t\tApp.ChartModel.on( \"change-map\", this.onChartModelChange, this );\n\n\t\t\treturn this.render();\n\t\t},\n\n\t\trender: function() {\n\t\t\tvar mapConfig = App.ChartModel.get( \"map-config\" ),\n\t\t\t\tminYear = App.DataModel.get(\"minYear\"),\n\t\t\t\tmaxYear = App.DataModel.get(\"maxYear\");\n\t\t\t\n\t\t\tthis.$targetYearLabel.text( mapConfig.targetYear );\n\t\t\tthis.$regionControlLabel.text( mapConfig.projection );\n\n\t\t\tthis.$targetYearInput.attr( \"min\", minYear );\n\t\t\tthis.$targetYearInput.attr( \"max\", maxYear );\n\t\t\tthis.$targetYearInput.attr( \"step\", mapConfig.timeInterval );\n\t\t\tthis.$targetYearInput.val( parseInt( mapConfig.targetYear, 10 ) );\n\n\t\t\tthis.$regionControlLis.removeClass( \"highlight\" );\n\t\t\tthis.$regionControlLis.filter( \".\" + mapConfig.projection + \"-projection\" ).addClass( \"highlight\" );\n\n\t\t\tthis.$settingsControl.find(\"input\").prop(\"checked\", mapConfig.mode !== \"no-interpolation\");\n\t\t\tthis.$colorBlindControl.toggleClass(\"active\", !!mapConfig.isColorblind);\n\n\t\t\t//is interval mode display\n\t\t\tif( isNaN( minYear ) || isNaN( maxYear ) ) {\n\t\t\t\tthis.$targetYearInput.attr( \"disabled\", true );\n\t\t\t}\n\t\t},\n\n\t\tonChartModelChange: function( evt ) {\n\t\t\tthis.render();\n\t\t},\n\t\t\n\t\tonTargetYearInput: function( evt ) {\n\t\t\tvar $this = $( evt.target ),\n\t\t\t\ttargetYear = parseInt( $this.val(), 10 );\n\t\t\tthis.$targetYearLabel.text( targetYear, false, \"change-map\" );\n\t\t},\n\n\t\tonTargetYearChange: function( evt ) {\n\t\t\tvar $this = $( evt.target ),\n\t\t\t\ttargetYear = parseInt( $this.val(), 10 );\n\t\t\tApp.ChartModel.updateMapConfig( \"targetYear\", targetYear, false, \"change-map\" );\n\t\t\tthis.render();\n\t\t},\n\n\t\tonRegionClick: function( evt ) {\n\t\t\tvar $this = $( evt.target );\n\t\t\tApp.ChartModel.updateMapConfig( \"projection\", $this.text(), false, \"change-map\" );\n\t\t\tthis.render();\n\t\t},\n\n\t\tonSettingsInput: function(evt) {\n\t\t\tvar $this = $(evt.target),\n\t\t\t\tcurrentMode = App.ChartModel.get(\"map-config\").mode,\n\t\t\t\tmode = currentMode === \"no-interpolation\" ? \"specific\" : \"no-interpolation\";\n\t\t\tApp.ChartModel.updateMapConfig(\"mode\", mode, false, \"change-map\");\n\t\t\tthis.render();\n\t\t},\n\n\t\tonColorBlindClick: function(evt) {\n\t\t\tvar $this = $(evt.currentTarget);\n\t\t\tif (!$this.hasClass(\"active\")) {\n\t\t\t\tApp.ChartModel.updateMapConfig(\"isColorblind\", true, false, \"change-map\");\n\t\t\t} else {\n\t\t\t\tApp.ChartModel.updateMapConfig(\"isColorblind\", false, false, \"change-map\");\n\t\t\t}\n\t\t},\n\n\t});\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Map.PlayPauseControl\");\n\n\tApp.Views.Chart.Map.PlayPauseControl = Backbone.View.extend({\n\t\tPLAY_INTERVAL: 500,\n\n\t\tel: \"#map-chart-tab .map-timeline-controls .play-pause-control\",\n\t\tevents: {\n\t\t\t\"click .play-btn\": \"onPlayClick\",\n\t\t\t\"click .pause-btn\": \"onPauseClick\",\n\t\t},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\n\t\t\tthis.interval = null;\n\t\t\tthis.$playBtn = this.$el.find( \".play-btn\" );\n\t\t\tthis.$pauseBtn = this.$el.find( \".pause-btn\" );\n\t\t\t\n\t\t\tthis.dispatcher.on( \"max-increment-time\", this.onMaxIncrement, this );\n\t\t},\n\n\t\trender: function() {\n\t\t\t\n\t\t},\n\n\t\tonPlayClick: function(evt) {\n\t\t\tif (evt)\n\t\t\t\tevt.preventDefault();\n\n\t\t\tvar mapConfig = App.ChartModel.get(\"map-config\"),\n\t\t\t\ttargetYear = mapConfig.targetYear,\n\t\t\t\tminYear = mapConfig.minYear,\n\t\t\t\tmaxYear = mapConfig.maxYear;\n\n\t\t\tif (targetYear == maxYear)\n\t\t\t\tApp.ChartModel.updateMapConfig(\"targetYear\", minYear, false, \"change-map-year\");\n\t\t\t\n\t\t\tthis.startTimer();\n\t\t\tthis.$pauseBtn.show();\n\t\t\tthis.$playBtn.hide();\n\t\t},\n\n\t\tonPauseClick: function( evt ) {\n\t\t\tif( evt ) {\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t\tthis.clearTimer();\n\n\t\t\tthis.$pauseBtn.hide();\n\t\t\tthis.$playBtn.show();\n\t\t},\n\n\t\tstartTimer: function() {\n\t\t\tthis.clearTimer();\n\t\t\tvar that = this;\n\t\t\tthis.interval = setInterval( function() {\n\t\t\t\tthat.incrementTime();\n\t\t\t\t}, this.PLAY_INTERVAL\n\t\t\t);\n\t\t\tthat.incrementTime();\n\t\t},\n\n\t\tonMaxIncrement: function() {\n\t\t\tthis.onPauseClick();\n\t\t},\n\n\t\tincrementTime: function() {\n\t\t\tthis.dispatcher.trigger( \"increment-time\" );\n\t\t},\n\n\t\tclearTimer: function() {\n\t\t\tif( this.interval ) {\n\t\t\t\tclearInterval( this.interval );\n\t\t\t}\n\t\t},\n\n\t\tshow: function() {\n\t\t\tthis.$el.css( \"display\", \"block\" );\n\t\t},\n\n\t\thide: function() {\n\t\t\tthis.$el.css( \"display\", \"none\" );\n\t\t}\n\n\t});\n})();",";(function() {\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Map.TimelineControl\");\n\t\n\tApp.Views.Chart.Map.TimelineControl = Backbone.View.extend({\n\t\tel: \"#map-chart-tab .map-timeline-controls .timeline-control\",\n\t\tevents: {\n\t\t\t\"mousedown\": \"onMousedown\",\n\t\t\t\"touchstart\": \"onTouchstart\"\n\t\t},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\t\n\t\t\tvar mapConfig = App.ChartModel.get( \"map-config\" );\n\t\t\t\n\t\t\tthis.$sliderWrapper = this.$el.find( \".timeline-wrapper\" );\n\t\t\tthis.$slider = this.$el.find( \".timeline-slider\" );\n\t\t\tthis.$sliderLabel = this.$slider.find( \".timeline-slider-label\" );\n\t\t\tthis.$sliderInput = this.$sliderWrapper.find( \"[type='range']\" );\n\n\t\t\tthis.$startYear = this.$el.find( \".timeline-start-year\" );\n\t\t\tthis.$endYear = this.$el.find( \".timeline-end-year\" );\n\n\t\t\tthis.dispatcher.on(\"increment-time\", this.onIncrementTime, this);\n\t\t\tApp.ChartModel.on(\"change-map\", this.onChangeYear, this);\n\t\t\tApp.ChartModel.on(\"change-map-year\", this.onChangeYear, this);\t\t\t\n\t\t},\n\n\t\tonMousedown: function(evt) {\n\t\t\tthis.isDragging = true;\n\t\t\t$(window).one(\"mouseup\", this.onMouseup.bind(this));\n\t\t\t$(window).on(\"mousemove.timeline\", this.onMousemove.bind(this));\n\t\t\tthis.onMousemove(evt);\n\t\t},\n\n\t\tonTouchstart: function(evt) {\n\t\t\tthis.isDragging = true;\n\t\t\t$(window).one(\"touchend\", this.onMouseup.bind(this));\n\t\t\t$(window).on(\"touchmove.timeline\", this.onMousemove.bind(this));\n\t\t\tthis.onMousemove(evt);\t\t\t\n\t\t},\n\n\t\tonMouseup: function() {\n\t\t\tthis.isDragging = false;\n\t\t\t$(window).off(\"touchend.timeline\");\n\t\t\t$(window).off(\"mousemove.timeline\");\n\t\t},\n\n\t\tonMousemove: function(evt) {\n\t\t\tif (!this.isDragging) return;\n\t\t\tevt.preventDefault();\n\n\t\t\tvar pageX = evt.pageX || evt.originalEvent.touches[0].pageX,\n\t\t\t\txPos = pageX - this.$sliderInput.offset().left,\n\t\t\t\tfracWidth = xPos / this.$sliderInput.width(),\n\t\t\t\ttargetYear = this.minYear + fracWidth*(this.maxYear-this.minYear);\n\n\t\t\tthis.setTargetYear(targetYear);\n\t\t},\n\n\t\tsetTargetYear: function(targetYear) {\n\t\t\t// Find the closest year that is a valid selection\n\t\t\tvar closestYear = _.min(this.years, function(year) {\n\t\t\t\treturn Math.abs(year-targetYear);\n\t\t\t});\n\n\t\t\tApp.ChartModel.updateMapConfig(\"targetYear\", closestYear, false, \"change-map-year\");\t\t\t\n\t\t},\n\n\t\trender: function() {\n\t\t\tvar mapConfig = App.ChartModel.get(\"map-config\"),\n\t\t\t\tminYear = App.DataModel.get(\"minYear\"),\n\t\t\t\tmaxYear = App.DataModel.get(\"maxYear\");\n\t\t\t\n\t\t\tthis.years = owid.timeRangesToYears(mapConfig.timeRanges, minYear, maxYear);\n\t\t\tthis.minYear = this.years[0];\n\t\t\tthis.maxYear = this.years[this.years.length-1];\n\t\t\tthis.targetYear = mapConfig.targetYear;\n\n\t\t\tthis.$startYear.text(owid.displayYear(this.minYear));\n\t\t\tthis.$endYear.text(owid.displayYear(this.maxYear));\n\n\t\t\tif (owid.displayYear(this.minYear).length > 4) \n\t\t\t\tthis.$startYear.css('font-size', '10px');\n\t\t\telse\n\t\t\t\tthis.$startYear.css('font-size', \"\");\n\n\t\t\tif (owid.displayYear(this.maxYear).length > 4) \n\t\t\t\tthis.$endYear.css('font-size', '10px');\n\t\t\telse\n\t\t\t\tthis.$endYear.css('font-size', \"\");\n\t\t\t\n\t\t\tthis.$sliderInput.attr( \"min\", this.minYear );\n\t\t\tthis.$sliderInput.attr( \"max\", this.maxYear );\n\t\t\t\n\t\t\tthis.updateSliderInput( this.targetYear );\n\t\t\t\n\t\t\tif (this.minYear == this.maxYear) {\n\t\t\t\tthis.$sliderInput.attr(\"disabled\", true);\n\t\t\t} else {\n\t\t\t\tthis.$sliderInput.attr(\"disabled\", false);\n\t\t\t}\n\n\t\t\tthis.createTicks(this.$sliderInput);\n\t\t},\n\n\t\tupdateSliderInput: function(time) {\n\t\t\tvar intTime = parseInt(time, 10),\n\t\t\t\tmin = parseInt( this.$sliderInput.attr( \"min\" ), 10 ),\n\t\t\t\tmax = parseInt( this.$sliderInput.attr( \"max\" ), 10 ),\n\t\t\t\tnewPoint = ( intTime - min ) / ( max - min );\n\t\t\t\n\t\t\tthis.$sliderLabel.text(owid.displayYear(time));\n\t\t\tthis.$slider.css(\"left\", this.$sliderWrapper.width()*newPoint);\n\t\t\tthis.$sliderInput.val(intTime);\n\t\t\tif (intTime === min || intTime === max) {\n\t\t\t\tthis.$sliderLabel.hide();\n\t\t\t\tthis.$sliderInput.removeClass( \"thumb-label\" );\n\t\t\t\tif( intTime === min ) {\n\t\t\t\t\tthis.$startYear.addClass( \"highlight\" );\n\t\t\t\t\tthis.$endYear.removeClass( \"highlight\" );\n\t\t\t\t} else {\n\t\t\t\t\tthis.$startYear.removeClass( \"highlight\" );\n\t\t\t\t\tthis.$endYear.addClass( \"highlight\" );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.$sliderLabel.show();\n\t\t\t\tthis.$sliderInput.addClass( \"thumb-label\" );\n\t\t\t\tthis.$startYear.removeClass( \"highlight\" );\n\t\t\t\tthis.$endYear.removeClass( \"highlight\" );\n\t\t\t}\n\t\t},\n\n\t\tonChangeYear: function() {\n\t\t\tvar targetYear = App.ChartModel.get(\"map-config\").targetYear;\n\t\t\tthis.updateSliderInput(targetYear);\n\n\t\t\tif (targetYear != parseInt(this.$sliderInput.val()))\n\t\t\t\tthis.$sliderInput.trigger(\"change\");\t\t\n\t\t},\n\n\t\tonIncrementTime: function( evt ) {\n\t\t\tvar currentYear = parseInt(this.$sliderInput.val()),\n\t\t\t\tindex = this.years.indexOf(currentYear);\n\n\t\t\tvar nextIndex = index+1;\n\t\t\tif (nextIndex >= this.years.length) {\n\t\t\t\tthis.dispatcher.trigger( \"max-increment-time\" );\n\t\t\t\treturn;\t\t\t\t\n\t\t\t}\n\n\t\t\tvar nextYear = this.years[nextIndex];\n\t\t\tthis.setTargetYear(nextYear);\n\t\t},\n\n\t\tcreateTicks: function( $input ) {\n\t\t\tif( this.$el.find( \".timeline-ticks\" ).length ) {\n\t\t\t\t//this.$el.find(\".timeline-ticks\").remove();\n\t\t\t\t//already has ticks, bail\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar min = this.minYear,\n\t\t\t\tmax = this.maxYear,\n\t\t\t\trangeSize = max-min,\n\t\t\t\thtmlString = \"<ol class='timeline-ticks'>\";\t\n\n\t\t\t_.each(this.years, function(year, i) {\n\t\t\t\tvar progress = (year-min) / rangeSize,\n\t\t\t\t\tpercent = progress*100,\n\t\t\t\t\ttranslate = \"translate(-\" + percent + \"%, 0)\",\n\t\t\t\t\ttickString = \"<li style='left:\" + percent + \"%;-webkit-transform:\" + translate + \";-ms-transform:\" + translate + \";transform:\" + translate + \"'>\" + year + \"</li>\";\n\t\t\t\thtmlString += tickString;\n\t\t\t});\n\n\t\t\thtmlString += \"</ol>\";\n\t\t\t$input.after( $( htmlString ) );\n\t\t},\n\n\t\tshow: function() {\n\t\t\tthis.$el.css( \"display\", \"block\" );\n\t\t},\n\n\t\thide: function() {\n\t\t\tthis.$el.css( \"display\", \"none\" );\n\t\t}\n\n\t});\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Map.ButtonsControl\");\n\t\n\tApp.Views.Chart.Map.ButtonsControl = Backbone.View.extend({\n\n\t\tel: \"#map-chart-tab .map-timeline-controls .buttons-control\",\n\t\tevents: {},\n\n\t\tinitialize: function( options ) {\n\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\tthis.$buttonsWrapper = this.$el.find( \".buttons-wrapper\" );\n\n\t\t\tApp.ChartModel.on( \"change\", this.onChartModelChange, this );\n\t\t\tApp.ChartModel.on( \"change-map\", this.onChartModelChange, this );\n\t\t\tApp.ChartModel.on( \"change-map-year\", this.onChartModelChange, this );\n\t\t},\n\n\t\trender: function() {\n\t\t\tvar mapConfig = App.ChartModel.get( \"map-config\" ),\n\t\t\t\ttargetYear = mapConfig.targetYear,\n\t\t\t\tminYear = App.DataModel.get(\"minYear\"),\n\t\t\t\tmaxYear = App.DataModel.get(\"maxYear\"),\n\t\t\t\tyears = owid.timeRangesToYears(mapConfig.timeRanges, minYear, maxYear);\n\n\t\t\t//create all necessary buttons\n\t\t\tthis.$buttonsWrapper.empty();\n\n\t\t\tvar htmlString = \"\";\n\t\t\t_.each(years, function(year) {\n\t\t\t\tvar selected = ( year == targetYear )? \"selected\": \"\";\n\t\t\t\thtmlString += \"<li data-year='\" + year + \"' class='year-btn \" + selected + \"'><a href='#' class='btn'>\" + owid.displayYear(year) + \"</a></li>\";\n\t\t\t});\n\t\t\t\n\t\t\tthis.$buttonsWrapper.append( $( htmlString ) );\n\t\t\t\n\t\t\tthis.$buttons = this.$buttonsWrapper.find( \"li\" );\n\t\t\tthis.$buttons.on( \"click\", $.proxy( this.onButtonClick, this ) );\n\n\t\t},\n\n\t\tonButtonClick: function( evt ) {\n\t\t\tevt.preventDefault();\n\t\t\tvar $btn = $( evt.currentTarget ),\n\t\t\t\ttargetYear = parseInt( $btn.attr( \"data-year\" ), 10 );\n\t\t\tApp.ChartModel.updateMapConfig(\"targetYear\", targetYear, false, \"change-map-year\");\n\t\t\n\t\t},\n\n\t\tonChartModelChange: function() {\n\t\t\tthis.render();\n\t\t},\n\n\t\tshow: function() {\n\t\t\tthis.$el.css( \"display\", \"table\" );\n\t\t},\n\n\t\thide: function() {\n\t\t\tthis.$el.css( \"display\", \"none\" );\n\t\t}\n\n\t});\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Map.TimelineControls\");\n\tvar PlayPauseControl = App.Views.Chart.Map.PlayPauseControl,\n\t\tTimelineControl = App.Views.Chart.Map.TimelineControl,\n\t\tButtonsControl = App.Views.Chart.Map.ButtonsControl;\n\n\tApp.Views.Chart.Map.TimelineControls = Backbone.View.extend({\n\t\tel: \"#map-chart-tab .map-timeline-controls\",\n\t\tevents: {},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\n\t\t\tthis.playPauseControl = new PlayPauseControl( options );\n\t\t\tthis.timelineControl = new TimelineControl( options );\n\t\t\tthis.buttonsControl = new ButtonsControl( options );\n\n\t\t\tApp.ChartModel.on( \"change-map\", this.onChartModelChange, this );\n\n\t\t\treturn this.render();\n\t\t},\n\n\t\trender: function() {\n\t\t\tvar mapConfig = App.ChartModel.get(\"map-config\");\n\t\t\t\n\t\t\tthis.playPauseControl.render();\n\t\t\tthis.timelineControl.render();\n\t\t\tthis.buttonsControl.render();\n\n\t\t\t//depending on the mode used display timeline mode or buttons mode\n\t\t\tif (mapConfig.timelineMode === \"buttons\") {\t\n\t\t\t\tthis.playPauseControl.hide();\n\t\t\t\tthis.timelineControl.hide();\n\t\t\t\tthis.buttonsControl.show();\n\t\t\t} else {\n\t\t\t\tthis.playPauseControl.show();\n\t\t\t\tthis.timelineControl.show();\n\t\t\t\tthis.buttonsControl.hide();\n\t\t\t}\n\n\t\t\t//should be timline disabled\n\t\t\tvar isRange = ( isNaN( mapConfig.minYear ) || isNaN( mapConfig.maxYear ) )? true: false,\n\t\t\t\tisSingleYear = ( !isRange && ( mapConfig.minYear == mapConfig.maxYear ) )? true: false;\n\n\t\t\tif( isRange || isSingleYear ) {\n\t\t\t\tthis.$el.addClass( \"single-year\" );\n\t\t\t} else {\n\t\t\t\tthis.$el.removeClass( \"single-year\" );\n\t\t\t}\n\t\t},\n\n\t\tonChartModelChange: function() {\n\t\t\tthis.render();\n\t\t}\n\n\t});\n})();",";(function() {\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Map.Projections\");\n\n\tApp.Views.Chart.Map.Projections = {\n\t\t\"World\": function(element) {\n\t\t\t//empiric\n\t\t\tvar k = 7.5;\n\t\t\tvar projection = d3.geo.eckert3()\n\t\t\t\t.precision(0.1);\n\t\t\tvar path = d3.geo.path().projection(projection);\n\t\t\treturn {path: path, projection: projection };\n\t\t},\n\t\t\"Africa\": function(element) {\n\t\t\t//empiric\n\t\t\tvar k = 3.2;\n\t\t\tvar projection = d3.geo.conicConformal()\n\t\t\t\t.rotate([-25, 0])\n\t\t\t\t.center([0, 0])\n\t\t\t\t.parallels([30, -20]);\n\t\t\tvar path = d3.geo.path().projection(projection);\n\t\t\treturn {path: path, projection: projection};\n\t\t},\n\t\t\"N.America\": function(element) {\n\t\t\t//empiric\n\t\t\tvar k = 3.2;\n\t\t\tvar projection = d3.geo.conicConformal()\n\t\t\t\t.rotate([98, 0])\n\t\t\t\t.center([0, 38])\n\t\t\t\t.parallels([29.5, 45.5]);\n\t\t\tvar path = d3.geo.path().projection(projection);\n\t\t\treturn {path: path, projection: projection};\n\t\t},\n\t\t\"S.America\": function(element) {\n\t\t\t//empiric\n\t\t\tvar k = 3.6;\n\t\t\tvar projection = d3.geo.conicConformal()\n\t\t\t\t.rotate([68, 0])\n\t\t\t\t.center([0, -14])\n\t\t\t\t.parallels([10, -30]);\n\t\t\tvar path = d3.geo.path().projection(projection);\n\t\t\treturn {path: path, projection: projection};\n\t\t},\n\t\t\"Asia\": function(element) {\n\t\t\t//empiric\n\t\t\tvar k = 3.2;\n\t\t\tvar projection = d3.geo.conicConformal()\n\t\t\t\t.rotate([-105, 0])\n\t\t\t\t.center([0, 37])\n\t\t\t\t.parallels([10, 60]);\n\t\t\tvar path = d3.geo.path().projection(projection);\n\t\t\treturn {path: path, projection: projection};\n\t\t},\n\t\t\"Europe\": function(element) {\n\t\t\t//empiric\n\t\t\tvar k = 1.7;\n\t\t\tvar projection = d3.geo.conicConformal()\n\t\t\t\t.rotate([-15, 0])\n\t\t\t\t.center([0, 55])\n\t\t\t\t.parallels([60, 40]);\n\t\t\tvar path = d3.geo.path().projection(projection);\n\t\t\treturn {path: path, projection: projection};\n\t\t},\n\t\t\"Australia\": function(element) {\n\t\t\t//empiric\n\t\t\tvar k = 3.2;\n\t\t\tvar projection = d3.geo.conicConformal()\n\t\t\t\t.rotate([-135, 0])\n\t\t\t\t.center([0, -20])\n\t\t\t\t.parallels([-10, -30]);\n\t\t\tvar path = d3.geo.path().projection(projection);\n\t\t\treturn {path: path, projection: projection};\n\t\t}\n\t};\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.Map.Legend\");\n\n\tApp.Views.Chart.Map.Legend = function() {\n\n\t\t//private\n\t\tvar stepSize = 20,\n\t\t\tstepClass = \"legend-step\",\n\t\t\tlegendOffsetX = 15,\n\t\t\tlegendOffsetY = 10,\n\t\t\tdisplayMinLabel = true,\n\t\t\tlabels = [], \n\t\t\torientation = \"landscape\",\n\t\t\tavailableHeight = 0,\n\t\t\tunit = {},\n\t\t\tscale, minData, maxData, datamap, container, containerHeight, isCategoricalScale, descriptionHeight, g, gDesc;\n\n\t\tvar formatLegendLabel = function(text, valueArr, i, length) {\n\t\t\tvalueArr = valueArr.map(function(d) {\n\t\t\t\tvar formattedNumber;\n\t\t\t\tif (d) {\n\t\t\t\t\tformattedNumber = owid.unitFormat(unit, d);\n\t\t\t\t} else {\n\t\t\t\t\t//see if we're suppose to display minimal value\n\t\t\t\t\tif (displayMinLabel)\n\t\t\t\t\t\tformattedNumber = owid.unitFormat(unit, minData || 0);\n\t\t\t\t}\n\t\t\t\t// HACK (Mispy): Don't use the unit suffix if it's too long\n\t\t\t\tif (formattedNumber.length >= 12)\n\t\t\t\t\tformattedNumber = formattedNumber.match(/[0-9,.]+/)[0] || formattedNumber;\n\t\t\t\treturn formattedNumber;\n\t\t\t} );\n\n\t\t\tif (i < (length - 1)) {\n\t\t\t\ttext.text(valueArr[0]);\n\t\t\t} else {\n\t\t\t\ttext.selectAll(\"tspan\").remove();\n\t\t\t\t//need to use tspan with preserve to have the whitespcae (??)\n\t\t\t\ttext.append(\"tspan\")\n\t\t\t\t\t.attr(\"class\", \"last-label-tspan\")\n\t\t\t\t\t.text(valueArr[0]);\n\t\t\t\ttext.append(\"tspan\")\n\t\t\t\t\t.attr(\"class\", \"last-label-tspan\")\n\t\t\t\t\t.text(valueArr[1]);\n\t\t\t}\n\n\t\t};\n\n\t\tvar formatCategoricalLegendLabel = function( i, scale ) {\n\t\t\treturn scale.domain()[ i ];\n\t\t};\n\n\t\tfunction legend(selection) {\n\t\t\tselection.each(function(data) {\n\t\t\t\tvar svgBounds = $(\"svg\").get(0).getBoundingClientRect(),\n\t\t\t\t\ttabBounds = $(\".tab-pane.active\").get(0).getBoundingClientRect(),\n\t\t\t\t\tavailableWidth = tabBounds.width,\n\t\t\t\t\tavailableSpace = (orientation == \"landscape\" ? availableWidth : availableHeight) * 0.6;\n\n\t\t\t\tvar effectiveStepSize = Math.min(30, Math.max((availableSpace / data.scheme.length) - 10, 10)),\n\t\t\t\t\tstepSizeWidth = effectiveStepSize,\n\t\t\t\t\tstepSizeHeight = effectiveStepSize,\n\t\t\t\t\tstepGap = Math.min(effectiveStepSize/8, 2);\n\n\t\t\t\tdatamap = d3.select(\".datamap\");\n\t\t\t\tcontainer = d3.select(this);\n\t\t\t\tisCategoricalScale = ( !scale || !scale.hasOwnProperty( \"invertExtent\" ) )? true: false;\n\t\t\t\tdescriptionHeight = ( data.description && data.description.length )? 12: 0;\n\t\t\t\tg = container.select( \".legend\" );\n\n\t\t\t\tif (g.empty()) {\n\t\t\t\t\tg = selection.append( \"g\" )\n\t\t\t\t\t\t\t.attr( \"id\", \"legend\" )\n\t\t\t\t\t\t\t.attr( \"class\", \"legend\" );\n\t\t\t\t}\n\n\t\t\t\t//data join\n\t\t\t\tvar legendSteps = g.selectAll(\".\" + stepClass).data(data.scheme);\n\t\t\t\t\n\t\t\t\t//enter\n\t\t\t\tvar legendStepsEnter = legendSteps.enter()\n\t\t\t\t\t.append( \"g\" )\n\t\t\t\t\t\t.attr( \"class\", stepClass );\n\t\t\t\tlegendStepsEnter.append(\"rect\");\n\t\t\t\tlegendStepsEnter.append(\"line\");\n\t\t\t\tlegendStepsEnter.append(\"text\");\n\n\t\t\t\t//vars for landscape\n\t\t\t\tvar maxDataIndex = data.scheme.length - 1,\n\t\t\t\t\tlegendStepsOffsetX = legendOffsetX;\n\t\t\t\tif( orientation === \"portrait\" && data.description ) {\n\t\t\t\t\tlegendStepsOffsetX += 5;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//update\n\t\t\t\tlegendSteps\n\t\t\t\t\t.attr( \"transform\", function( d, i ) { var translateX = ( orientation === \"landscape\" )? legendStepsOffsetX + (i*(stepSizeWidth+stepGap)): legendStepsOffsetX, translateY = ( orientation === \"landscape\" )? 0: ( -( maxDataIndex - i ) * ( stepSizeHeight + stepGap ) ); return \"translate(\" + translateX + \",\" + translateY + \")\"; } );\n\t\t\t\tlegendSteps.selectAll( \"rect\" )\n\t\t\t\t\t.attr( \"width\", stepSizeWidth + \"px\" )\n\t\t\t\t\t.attr( \"height\", stepSizeHeight + \"px\" );\n\n\t\t\t\tlegendSteps.select( \"rect\" )\n\t\t\t\t\t.style( \"fill\", function( d, i ) {\n\t\t\t\t\t\t\treturn d;\n\t\t\t\t\t\t} );\n\t\t\t\t\n\t\t\t\t//is there custom labeling for \n\t\t\t\tvar legendStepsTexts = legendSteps.select(\"text\")\n\t\t\t\t\t\t\t.attr( \"transform\", function( d, i ) {\n\t\t\t\t\t\t\t\tvar stepSizeX = stepSizeWidth/2 + 4;\n\n\t\t\t\t\t\t\t\tif ( orientation === \"portrait\" ) {\n\t\t\t\t\t\t\t\t\t//translate for portrait\n\t\t\t\t\t\t\t\t\tif( isCategoricalScale || ( labels.length && labels[i] ) ) {\n\t\t\t\t\t\t\t\t\t\treturn \"translate(\" + (stepSizeWidth+5) + \",\" + (stepSizeHeight/2+3) + \")\";\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn \"translate(\" + (stepSizeWidth+5) + \",\" + (2) + \")\";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t//translate for landscape\n\t\t\t\t\t\t\t\t\tif( !isCategoricalScale && ( !labels.length || !labels[i] ) ) {\n\t\t\t\t\t\t\t\t\t\treturn \"translate(-2,-5) rotate(270)\";\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn \"translate(\" + stepSizeX + \",-5) rotate(270)\";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.each(function(d, i) {\n\t\t\t\t\t\t\t\tvar text = d3.select(this);\n\n\t\t\t\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\t\t\t\ttext.text(labels[i]);\n\t\t\t\t\t\t\t\t} else if (isCategoricalScale) {\n\t\t\t\t\t\t\t\t\ttext.text(formatCategoricalLegendLabel(i, scale));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tformatLegendLabel(text, scale.invertExtent(d), i, data.scheme.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\t//position last tspans\n\t\t\t\tvar legendStepsTspans = legendStepsTexts.selectAll( \"tspan.last-label-tspan\" ),\n\t\t\t\t\tfirstTspanLength = 0;\n\t\t\t\tlegendStepsTspans.each(function(d, i) {\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tfirstTspanLength = this.getComputedTextLength();\n\t\t\t\t\t} else if (i === 1) {\n\t\t\t\t\t\tvar dx = -firstTspanLength; //need to reset possible previous offset\n\t\t\t\t\t\tvar dy = stepSizeHeight;\n\t\t\t\t\t\td3.select(this).attr({ \"dx\": dx, \"dy\": dy });\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\t\n\t\t\t\t//exit\n\t\t\t\tlegendSteps.exit().remove();\n\n\t\t\t\t//legend description\n\t\t\t\tgDesc = container.selectAll(\".legend-description\").data([data.description]);\n\t\t\t\tgDesc.enter()\n\t\t\t\t\t.append(\"text\")\n\t\t\t\t\t.attr(\"class\", \"legend-description\");\n\t\t\t\tgDesc\n\t\t\t\t\t.text(data.description);\n\t\t\t\tgDesc.attr( \"transform\", function( d, i ) { var translateX = legendOffsetX, translateY = ( orientation === \"landscape\" )? stepSizeHeight+descriptionHeight: stepSizeHeight; return ( orientation === \"landscape\" )? \"translate(\" + translateX + \",\" + translateY + \")\": \"translate(\" + translateX + \",\" + translateY + \") rotate(270)\"; } );\n\n\t\t\t\t//position legend vertically\n\t\t\t\tvar legendY = (tabBounds.top - svgBounds.top) + availableHeight - legendOffsetY - stepSizeHeight;\n\t\t\t\tif (orientation === \"landscape\") {\n\t\t\t\t\tlegendY -= descriptionHeight;\n\t\t\t\t}\n\n\t\t\t\tcontainer.attr(\"transform\", \"translate(0,\" + legendY + \")\");\n\n\t\t\t});\n\n\t\t\treturn legend;\n\n\t\t}\n\n\t\t//public methods\n\t\tlegend.stepSize = function(value) {\n\t\t\tif(!arguments.length) {\n\t\t\t\treturn stepSize;\n\t\t\t} else {\n\t\t\t\tstepSize = parseInt(value, 10);\n\t\t\t}\n\t\t};\n\t\tlegend.scale = function( value ) {\n\t\t\tif( !arguments.length ) {\n\t\t\t\treturn scale;\n\t\t\t} else {\n\t\t\t\tscale = value;\n\t\t\t}\n\t\t};\n\t\tlegend.minData = function( value ) {\n\t\t\tif( !arguments.length ) {\n\t\t\t\treturn minData;\n\t\t\t} else {\n\t\t\t\tminData = value;\n\t\t\t}\n\t\t};\n\t\tlegend.maxData = function( value ) {\n\t\t\tif( !arguments.length ) {\n\t\t\t\treturn maxData;\n\t\t\t} else {\n\t\t\t\tmaxData = value;\n\t\t\t}\n\t\t};\n\t\tlegend.displayMinLabel = function( value ) {\n\t\t\tif( !arguments.length ) {\n\t\t\t\treturn displayMinLabel;\n\t\t\t} else {\n\t\t\t\tdisplayMinLabel = value;\n\t\t\t}\n\t\t};\n\t\tlegend.labels = function( value ) {\n\t\t\tif( !arguments.length ) {\n\t\t\t\treturn labels;\n\t\t\t} else {\n\t\t\t\t//set sensible default\n\t\t\t\tif( !value ) {\n\t\t\t\t\tvalue = [];\n\t\t\t\t}\n\t\t\t\tlabels = value;\n\t\t\t}\n\t\t};\n\t\tlegend.orientation = function( value ) {\n\t\t\tif( !arguments.length ) {\n\t\t\t\treturn orientation;\n\t\t\t} else {\n\t\t\t\torientation = value;\n\t\t\t}\n\t\t};\n\t\tlegend.availableHeight = function(value) {\n\t\t\tif (!arguments.length)\n\t\t\t\treturn availableHeight;\n\t\t\telse\n\t\t\t\tavailableHeight = value;\n\t\t};\n\t\tlegend.unit = function(value) {\n\t\t\tif (!arguments.length)\n\t\t\t\treturn unit;\n\t\t\telse\n\t\t\t\tunit = value;\n\t\t};\n\n\t\treturn legend;\n\n\t};\n})();",";(function() {\n\t\"use strict\";\n\towid.namespace(\"App.Views.Chart.MapTab\");\n\n\tvar MapControls = App.Views.Chart.Map.MapControls,\n\t\tTimelineControls = App.Views.Chart.Map.TimelineControls,\n\t\towdProjections = App.Views.Chart.Map.Projections,\n\t\tLegend = App.Views.Chart.Map.Legend,\n\t\tChartDataModel = App.Models.ChartDataModel;\n\n\tApp.Views.Chart.MapTab = Backbone.View.extend({\n\n\t\tBORDERS_DISCLAIMER_TEXT: \"Mapped on current borders\",\n\n\t\tel: \"#chart-view\",\n\t\tdataMap: null,\n\t\tmapControls: null,\n\t\tlegend: null,\n\t\tbordersDisclaimer: null,\n\t\tevents: {},\n\n\t\tinitialize: function( options ) {\n\t\t\tthis.dispatcher = options.dispatcher;\n\t\t\tthis.parentView = options.parentView;\n\t\t\tthis.vardataModel = options.vardataModel;\n\t\t\tthis.$tab = this.$el.find(\"#map-chart-tab\");\n\t\t},\n\n\t\tactivate: function(callback) {\n\t\t\tif (!this.mapControls)\n\t\t\t\tthis.mapControls = new MapControls( { dispatcher: this.dispatcher } );\n\t\t\tif (!this.timelineControls)\n\t\t\t\tthis.timelineControls = new TimelineControls( { dispatcher: this.dispatcher } );\n\n\t\t\tApp.ChartModel.on(\"change\", this.update, this);\n\t\t\tApp.ChartModel.on(\"change-map\", function() {\n\t\t\t\tthis.update();\n\t\t\t\tApp.ChartView.onResize();\n\t\t\t}.bind(this), this);\n\t\t\tApp.ChartModel.on(\"change-map-year\", this.updateYearOnly, this);\n\t\t\tthis.update(callback);\n\t\t},\n\n\t\tdeactivate: function() {\n\t\t\tApp.ChartModel.off(null, null, this);\n\t\t\t$(\".datamaps-hoverover\").remove();\n\t\t\td3.selectAll(\".datamaps-subunits, .border-disclaimer, .legend-wrapper, .map-bg\").remove();\t\t\t\n\t\t\t$(\"svg\").removeClass(\"datamap\");\n\t\t\tthis.dataMap = null;\n\t\t},\n\n\t\tupdate: function(callback) {\n\t\t\tthis.mapConfig = App.ChartModel.get(\"map-config\");\n\n\t\t\t// We need to wait for both datamaps to finish its setup and the variable data\n\t\t\t// to come in before the map can be fully rendered\n\t\t\tvar onMapReady = function() {\n\t\t\t\t$(\".chart-wrapper-inner\").attr(\"style\", \"\");\n\t\t\t\tApp.DataModel.ready(function() {\n\t\t\t\t\tthis.render(callback);\n\t\t\t\t}.bind(this));\t\t\t\t\n\t\t\t}.bind(this);\n\n\t\t\tif (!this.dataMap)\n\t\t\t\tthis.initializeMap(onMapReady);\n\t\t\telse\n\t\t\t\tonMapReady();\n\t\t},\n\n\t\t// Optimized method for updating the target year with the slider\n\t\tupdateYearOnly: _.throttle(function() {\n\t\t\tApp.DataModel.ready(function(variableData) {\n\t\t\t\tthis.mapData = this.transformData(variableData);\n\t\t\t\tthis.applyColors(this.mapData, this.colorScale);\n\t\t\t\tthis.dataMap.updateChoropleth(this.mapData, { reset: true });\n\t\t\t\tthis.parentView.header.render();\n\t\t\t}.bind(this));\n\t\t}, 100),\n\n\t\tinitializeMap: function(onMapReady) {\n\t\t\tvar self = this;\n\t\t\tvar defaultProjection = this.getProjection(this.mapConfig.projection);\n\n\t\t\tvar $oldSvg = $(\"svg\");\n\t\t\tthis.dataMap = new Datamap({\n\t\t\t\telement: $(\".chart-wrapper-inner\").get(0),\n\t\t\t\tresponsive: false,\n\t\t\t\tgeographyConfig: {\n\t\t\t\t\tdataUrl: Global.rootUrl + \"/build/js/data/world.ids.json\",\n\t\t\t\t\tborderWidth: 0.3,\n\t\t\t\t\tborderColor: '#4b4b4b',\n\t\t\t\t\thighlightFillColor: '#8b8b8b',\n\t\t\t\t\thighlightBorderWidth: 3,\n\t\t\t\t\thighlightBorderColor: '#FFEC38',\n\t\t\t\t\tpopupTemplate: self.popupTemplateGenerator,\n\t\t\t\t\thideAntarctica: true\n\t\t\t\t},\n\t\t\t\tfills: {\n\t\t\t\t\tdefaultFill: '#8b8b8b'\n\t\t\t\t},\n\t\t\t\tsetProjection: defaultProjection,\n\t\t\t\tdone: function() {\n\t\t\t\t\t// HACK (Mispy): Workaround for the fact that datamaps insists on creating\n\t\t\t\t\t// its own SVG element instead of injecting into an existing one.\n\t\t\t\t\t$oldSvg.children().appendTo($(\"svg.datamap\"));\n\t\t\t\t\t$oldSvg.remove();\n\n\t\t\t\t\td3.select(\"svg.datamap\").insert(\"rect\", \"*\")\n\t\t\t\t\t\t.attr(\"class\", \"map-bg\")\n\t\t\t\t\t\t.attr(\"x\", 0).attr(\"y\", 0);\n\t\t\t\t\tonMapReady();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// For maps earlier than 2011, display a disclaimer noting that data is mapped\n\t\t\t// on current rather than historical borders\n\t\t\tif (parseInt(self.mapConfig.minYear) <= 2011) {\n\t\t\t\tthis.bordersDisclaimer = d3.select( \".border-disclaimer\" );\n\t\t\t\tif (this.bordersDisclaimer.empty()) {\n\t\t\t\t\tthis.bordersDisclaimer = d3.select(\".datamap\").append(\"text\");\n\t\t\t\t\tthis.bordersDisclaimer.attr(\"class\", \"border-disclaimer\").text(this.BORDERS_DISCLAIMER_TEXT);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set configurable targets from defaults\n\t\t\tthis.mapConfig.targetYear = this.mapConfig.defaultYear || this.mapConfig.targetYear;\n\t\t\tthis.mapConfig.projection = this.mapConfig.defaultProjection || this.mapConfig.projection;\n\t\t},\n\n\t\tpopupTemplateGenerator: function(geo, data) {\n\t\t\tif (_.isEmpty(data)) return;\n\n\t\t\t//transform datamaps data into format close to nvd3 so that we can reuse the same popup generator\n\t\t\tvar mapConfig = App.ChartModel.get( \"map-config\" ),\n\t\t\t\tpropertyName = App.Utils.getPropertyByVariableId(App.ChartModel, mapConfig.variableId) || \"y\";\n\n\t\t\tvar obj = {\n\t\t\t\tpoint: {\n\t\t\t\t\ttime: data.year\n\t\t\t\t},\n\t\t\t\tseries: [{\n\t\t\t\t\tkey: geo.properties.name\n\t\t\t\t}]\n\t\t\t};\n\t\t\tobj.point[propertyName] = data.value;\n\t\t\treturn [\"<div class='hoverinfo nvtooltip'>\" + owid.contentGenerator( obj, true ) + \"</div>\"];\n\t\t},\n\n\t\tonChartModelChange: function( evt ) {\n\t\t\tthis.update();\n\t\t},\n\n\n\t\t/**\n\t\t * Transforms raw variable data into datamaps format\n\t\t * @param {Object} variableData - of the form { entities: [], values: [], years: [] }\n\t\t * @return {Object} mapData - of the form { 'Country': { value: 120.11, year: 2006 }, ...}\n\t\t */\n\t\ttransformData: function(variableData) {\n\t\t\tvar firstVariable = variableData.variables[this.mapConfig.variableId],\n\t\t\t\tyears = firstVariable.years,\n\t\t\t\tvalues = firstVariable.values,\n\t\t\t\tentities = firstVariable.entities,\n\t\t\t\tentityKey = variableData.entityKey,\n\t\t\t\ttargetYear = parseInt(this.mapConfig.targetYear),\n\t\t\t\ttolerance = parseInt(this.mapConfig.timeTolerance) || 1,\n\t\t\t\tmapData = {};\n\n\t\t\tif (this.mapConfig.mode === \"no-interpolation\")\n\t\t\t\ttolerance = 0;\n\n\t\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\t\tvar year = years[i];\n\t\t\t\tif (year < targetYear-tolerance || year > targetYear+tolerance) \n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Make sure we use the closest year within tolerance (favoring later years)\n\t\t\t\tvar current = mapData[entityName];\n\t\t\t\tif (current && Math.abs(current.year - targetYear) < Math.abs(year - targetYear))\n\t\t\t\t\tcontinue;\n\n\n\t\t\t\t// Transform entity name to match counterpart in world.ids.json\n\t\t\t\t// Covers e.g. Cote d'Ivoire -> Cote_d_Ivoire\n\t\t\t\tvar entityName = entityKey[entities[i]].name.replace(/[ '&:\\(\\)\\/]/g, \"_\");\n\n\t\t\t\tmapData[entityName] = {\n\t\t\t\t\tvalue: parseFloat(values[i]),\n\t\t\t\t\tyear: years[i]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.minValue = _.min(mapData, function(d, i) { return d.value; }).value;\n\t\t\tthis.maxValue = _.max(mapData, function(d, i) { return d.value; }).value;\n\t\t\tthis.minToleranceYear = _.min(mapData, function(d, i) { return d.year; }).year;\n\t\t\tthis.maxToleranceYear = _.max(mapData, function(d, i) { return d.year; }).year;\n\t\t\tthis.variableName = firstVariable.name;\n\n\n\t\t\t// HACK (Mispy): Ideally these calculated values shouldn't go in mapConfig,\n\t\t\t// but for backwards compatibility it's easier to have them there.\n\t\t\tvar rangeYears = owid.timeRangesToYears(this.mapConfig.timeRanges, years[0], years[years.length-1]);\n\t\t\tApp.ChartModel.updateMapConfig(\"minYear\", rangeYears[0], true);\n\t\t\tApp.ChartModel.updateMapConfig(\"maxYear\", rangeYears[rangeYears.length-1], true);\n\n\n\t\t\treturn mapData;\n\t\t},\n\n\t\tapplyColors: function(mapData, colorScale) {\n\t\t\t_.each(mapData, function(d, i) {\n\t\t\t\td.color = colorScale(d.value);\n\t\t\t\td.highlightFillColor = d.color;\n\t\t\t});\n\t\t},\n\n\t\trender: function(callback) {\n\t\t\ttry {\n\t\t\t\tvar variableData = App.DataModel.get(\"variableData\");\n\t\t\t\tthis.mapData = this.transformData(variableData);\n\t\t\t\tthis.colorScale = this.makeColorScale();\n\t\t\t\tthis.applyColors(this.mapData, this.colorScale);\n\n\t\t\t\t// If we've changed the projection (i.e. zooming on Africa or similar) we need\n\t\t\t\t// to redraw the datamap before injecting new data\n\t\t\t\tvar oldProjection = this.dataMap.options.setProjection,\n\t\t\t\t\tnewProjection = this.getProjection(this.mapConfig.projection);\n\n\t\t\t\tvar self = this;\n\t\t\t\tvar updateMap = function() {\n\t\t\t\t\tself.dataMap.updateChoropleth(self.mapData, { reset: true });\n\t\t\t\t\td3.selectAll(\"svg.datamap\").transition().each(\"end\", function() {\n\t\t\t\t\t\t$(window).trigger(\"chart-loaded\");\n\t\t\t\t\t});\n\t\t\t\t\tself.mapControls.render();\n\t\t\t\t\tself.timelineControls.render();\n\t\t\t\t\tif (callback) callback();\n\t\t\t\t\telse self.onResize();\n\t\t\t\t};\n\n\t\t\t\tif (oldProjection === newProjection) {\n\t\t\t\t\tupdateMap();\n\t\t\t\t} else {\n\t\t\t\t\td3.selectAll(\"path.datamaps-subunit\").remove();\n\t\t\t\t\tthis.dataMap.options.setProjection = newProjection;\n\t\t\t\t\tthis.dataMap.options.done = updateMap;\n\t\t\t\t\tthis.dataMap.draw();\n\t\t\t\t}\t\t\t\t\n\t\t\t} catch (err) {\n\t\t\t\tApp.ChartView.handleError(err);\t\n\t\t\t}\n\t\t},\n\n\t\tmakeColorScale: function() {\n\t\t\tvar mapConfig = this.mapConfig;\n\t\t\tvar colorScheme = owdColorbrewer.getColors(mapConfig);\n\n\t\t\tvar colorScale,\n\t\t\t\tcustomValues = mapConfig.colorSchemeValues,\n\t\t\t\tautomaticValues = mapConfig.colorSchemeValuesAutomatic;\n\n\t\t\tvar categoricalScale = false;\n\n\t\t\t//use quantize, if we have numerica scale and not using automatic values, or if we're trying not to use automatic scale, but there no manually entered custom values\n\t\t\tif( !categoricalScale && ( automaticValues || (!automaticValues && !customValues) ) ) {\n\t\t\t\t//we have quantitave scale\n\t\t\t\tcolorScale = d3.scale.quantize()\n\t\t\t\t\t.domain( [ this.minValue, this.maxValue ] );\n\t\t\t} else if( !categoricalScale && customValues && !automaticValues ) {\n\t\t\t\t//create threshold scale which divides data into buckets based on values provided\n\t\t\t\tcolorScale = d3.scale.equal_threshold()\n\t\t\t\t\t.domain( customValues );\n\t\t\t} else {\n/*\t\t\t\tvar keys = _.keys( keysArr );\n\t\t\t\tkeys = keys.sort();\n\t\t\t\tcolorScale = d3.scale.ordinal()\n\t\t\t\t\t.domain( _.keys( keysArr ) );*/\n\t\t\t}\n\t\t\tcolorScale.range(colorScheme);\n\n\t\t\treturn colorScale;\n\t\t},\n\n\t\tmakeLegend: function(availableHeight) {\n\t\t\tvar legend = this.legend || new Legend(),\n\t\t\t\tminValue = this.minValue,\n\t\t\t\tmaxValue = this.maxValue,\n\t\t\t\tmapConfig = this.mapConfig,\n\t\t\t\tcolorScale = this.colorScale;\n\n\t\t\tif (mapConfig.colorSchemeMinValue || mapConfig.colorSchemeValuesAutomatic) {\n\t\t\t\tlegend.displayMinLabel(true);\n\t\t\t} else {\n\t\t\t\tlegend.displayMinLabel(false);\n\t\t\t}\n\n\t\t\tvar unitsString = App.ChartModel.get(\"units\"),\n\t\t\t\tunits = !_.isEmpty(unitsString) ? $.parseJSON(unitsString) : {},\n\t\t\t\tyUnit = _.findWhere(units, { property: 'y' });\n\t\t\tlegend.unit(yUnit);\n\t\t\tlegend.labels(mapConfig.colorSchemeLabels);\n\n\t\t\tvar legendOrientation = mapConfig.legendOrientation || \"portrait\";\n\t\t\tlegend.orientation(legendOrientation);\n\t\t\tlegend.scale(colorScale);\n\n\t\t\t// Allow min value to overridden by config\n\t\t\tif (!isNaN(mapConfig.colorSchemeMinValue)) {\n\t\t\t\tminValue = mapConfig.colorSchemeMinValue;\n\t\t\t}\n\t\t\tlegend.minData(minValue);\n\t\t\tlegend.maxData(maxValue);\n\t\t\tlegend.availableHeight(availableHeight);\n\t\t\tif (d3.select(\".legend-wrapper\").empty()) {\n\t\t\t\td3.select(\".datamap\").append(\"g\").attr(\"class\", \"legend-wrapper map-legend-wrapper\");\n\t\t\t}\n\n\t\t\tvar legendData = { scheme: colorScale.range(), description: mapConfig.legendDescription || this.variableName };\n\t\t\td3.select(\".legend-wrapper\").datum(legendData).call(legend);\n\t\t\treturn legend;\n\t\t},\n\n\t\tgetProjection: function( projectionName ) {\n\t\t\tvar projections = owdProjections,\n\t\t\t\tnewProjection = ( projections[ projectionName ] )? projections[ projectionName ]: projections.World;\n\t\t\treturn newProjection;\n\t\t},\n\n\t\tonResize: function(callback) {\n\t\t\tvar map = d3.select(\".datamaps-subunits\");\t\t\t\n\t\t\tif (!this.dataMap || map.empty()) {\n\t\t\t\tif (callback) callback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar viewports = {\n\t\t\t\t\"World\": { x: 0.525, y: 0.5, width: 1, height: 1 },\n\t\t\t\t\"Africa\": { x: 0.48, y: 0.70, width: 0.21, height: 0.38 },\n\t\t\t\t\"N.America\": { x: 0.49, y: 0.40, width: 0.19, height: 0.32 },\n\t\t\t\t\"S.America\": { x: 0.52, y: 0.815, width: 0.10, height: 0.26 },\n\t\t\t\t\"Asia\": { x: 0.49, y: 0.52, width: 0.22, height: 0.38 },\n\t\t\t\t\"Australia\": { x: 0.51, y: 0.77, width: 0.1, height: 0.12 },\n\t\t\t\t\"Europe\": { x: 0.54, y: 0.54, width: 0.05, height: 0.15 },\n\t\t\t};\n\n\t\t\tvar viewport = viewports[App.ChartModel.get(\"map-config\").projection];\n\n\t\t\tvar options = this.dataMap.options,\n\t\t\t\tprefix = \"-webkit-transform\" in document.body.style ? \"-webkit-\" : \"-moz-transform\" in document.body.style ? \"-moz-\" : \"-ms-transform\" in document.body.style ? \"-ms-\" : \"\";\n\n\t\t\t// Calculate our reference dimensions. All of these values are independent of the current\n\t\t\t// map translation and scaling-- getBBox() gives us the original, untransformed values.\n\t\t\tvar svg = d3.select(\"svg\"),\n\t\t\t\tsvgBounds = svg.node().getBoundingClientRect(),\n\t\t\t\t$tab = $(\".tab-pane.active\"),\n\t\t\t\ttabBounds = $tab.get(0).getBoundingClientRect(),\n\t\t\t\tavailableWidth = tabBounds.right - tabBounds.left,\n\t\t\t\tavailableHeight = tabBounds.bottom - tabBounds.top,\n\t\t\t\tmapBBox = map.node().getBBox(),\n\t\t\t\tmapWidth = mapBBox.width,\n\t\t\t\tmapHeight = mapBBox.height,\n\t\t\t\tmapX = svgBounds.left + mapBBox.x + 1,\n\t\t\t\tmapY = svgBounds.top + mapBBox.y + 1,\n\t\t\t\tviewportWidth = viewport.width*mapWidth,\n\t\t\t\tviewportHeight = viewport.height*mapHeight;\n\n\t\t\t//console.log(\"wrapperWidth \" + wrapperWidth + \" wrapperHeight \" + wrapperHeight + \" mapWidth \" + mapWidth + \" mapHeight \" + mapHeight);\n\n\t\t\t// Resize background\n\t\t\tsvg.select(\".map-bg\")\n\t\t\t\t.attr(\"width\", svgBounds.width)\n\t\t\t\t.attr(\"height\", svgBounds.height);\n\n\t\t\t// Adjust availableHeight to compensate for timeline controls\n\t\t\tvar timelineControls = d3.select(\".map-timeline-controls\");\n\t\t\tif (!timelineControls.empty()) {\n\t\t\t\tvar controlsBoundingRect = timelineControls.node().getBoundingClientRect(),\n\t\t\t\t\tcontrolsHeight = controlsBoundingRect.bottom - controlsBoundingRect.top;\n\t\t\t\tavailableHeight -= controlsHeight;\n\t\t\t}\n\n\t\t\t// Calculate what scaling should be applied to the untransformed map to match the current viewport to the container\n\t\t\tvar scaleFactor = Math.min(availableWidth/viewportWidth, availableHeight/viewportHeight),\n\t\t\t\tscaleStr = \"scale(\" + scaleFactor + \")\";\n\n\t\t\t// Work out how to center the map, accounting for the new scaling we've worked out\n\t\t\tvar newWidth = mapWidth*scaleFactor,\n\t\t\t\tnewHeight = mapHeight*scaleFactor,\n\t\t\t\ttabCenterX = tabBounds.left + availableWidth / 2,\n\t\t\t\ttabCenterY = tabBounds.top + availableHeight / 2,\n\t\t\t\tnewCenterX = mapX + (scaleFactor-1)*mapBBox.x + viewport.x*newWidth,\n\t\t\t\tnewCenterY = mapY + (scaleFactor-1)*mapBBox.y + viewport.y*newHeight,\n\t\t\t\tnewOffsetX = tabCenterX - newCenterX,\n\t\t\t\tnewOffsetY = tabCenterY - newCenterY,\n\t\t\t\ttranslateStr = \"translate(\" + newOffsetX + \"px,\" + newOffsetY + \"px)\";\n\n\t\t\tvar matrixStr = \"matrix(\" + scaleFactor + \",0,0,\" + scaleFactor + \",\" + newOffsetX + \",\" + newOffsetY + \")\";\n\t\t\tmap.style(prefix + \"transform\", matrixStr);\n\n\t\t\tif (this.bordersDisclaimer && !this.bordersDisclaimer.empty()) {\n\t\t\t\tvar bordersDisclaimerEl = this.bordersDisclaimer.node(),\n\t\t\t\t\tbordersDisclaimerX = availableWidth - bordersDisclaimerEl.getComputedTextLength() - 10,\n\t\t\t\t\tbordersDisclaimerY = (tabBounds.top - svgBounds.top) + availableHeight - 10;\n\t\t\t\tthis.bordersDisclaimer.attr(\"transform\", \"translate(\" + bordersDisclaimerX + \",\" + bordersDisclaimerY + \")\");\n\t\t\t}\n\n\t\t\tthis.legend = this.makeLegend(availableHeight);\n\n\t\t\tif (callback) callback();\n\t\t\t/*wrapper.on(\"mousemove\", function() {\n\t\t\t\tvar point = d3.mouse(this);\n\t\t\t\tvar rect = map.node().getBoundingClientRect();\n\t\t\t\tvar wrapRect = wrapper.node().getBoundingClientRect();\n\t\t\t\tvar x = point[0] - (rect.left - wrapRect.left);\n\t\t\t\tvar y = point[1] - (rect.top - wrapRect.top);\n\t\t\t\tconsole.log([x/newWidth, y/newHeight]);\n\t\t\t});*/\n\t\t},\n\n\t});\n})();\n\n(function() {\n\tvar  = 1e-6, 2 =  * ,  = Math.PI, half =  / 2, sqrt = Math.sqrt(), radians =  / 180, degrees = 180 / ;\n\tfunction sinci(x) {\n\t\treturn x ? x / Math.sin(x) : 1;\n\t}\n\tfunction sgn(x) {\n\t\treturn x > 0 ? 1 : x < 0 ? -1 : 0;\n\t}\n\tfunction asin(x) {\n\t\treturn x > 1 ? half : x < -1 ? -half : Math.asin(x);\n\t}\n\tfunction acos(x) {\n\t\treturn x > 1 ? 0 : x < -1 ?  : Math.acos(x);\n\t}\n\tfunction asqrt(x) {\n\t\treturn x > 0 ? Math.sqrt(x) : 0;\n\t}\n\tvar projection = d3.geo.projection;\n\n\tfunction eckert3(, ) {\n\t\tvar k = Math.sqrt( * (4 + ));\n\t\treturn [ 2 / k *  * (1 + Math.sqrt(1 - 4 *  *  / ( * ))), 4 / k *  ];\n\t}\n\teckert3.invert = function(x, y) {\n\t\tvar k = Math.sqrt( * (4 + )) / 2;\n\t\treturn [ x * k / (1 + asqrt(1 - y * y * (4 + ) / (4 * ))), y * k / 2 ];\n\t};\n\t(d3.geo.eckert3 = function() {\n\t\treturn projection(eckert3);\n\t}).raw = eckert3;\n\n})();\n\n//custom implementation of d3_treshold which uses greaterThan (by using bisectorLeft instead of bisectorRight)\nd3.scale.equal_threshold = function() {\n  return d3_scale_equal_threshold([0.5], [0, 1]);\n};\n\nfunction d3_scale_equal_threshold(domain, range) {\n\n  function scale(x) {\n    if (x <= x) return range[d3.bisectLeft(domain, x)];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain;\n    domain = _;\n    return scale;\n  };\n\n  scale.range = function(_) {\n    if (!arguments.length) return range;\n    range = _;\n    return scale;\n  };\n\n  scale.invertExtent = function(y) {\n    y = range.indexOf(y);\n    return [domain[y - 1], domain[y]];\n  };\n\n  scale.copy = function() {\n    return d3_scale_threshold(domain, range);\n  };\n\n  return scale;\n}\n","/* App.Views.ChartURL.js                                                             \n * ================                                                             \n *\n * This view is responsible for handling data binding between the\n * the chart and url parameters, to enable nice linking support\n * for specific countries and years.\n *\n * @project Our World In Data\n * @author  Jaiden Mispy                                                     \n * @created 2016-03-31\n */ \n\n;(function() {\n\t\"use strict\";\n\towid.namespace(\"App.Views.ChartURL\");\n\n\tApp.Views.ChartURL = Backbone.View.extend({\n\t\tinitialize: function(options) {\n\t\t\tif (App.isEditor) return false; // No URL stuff while editing charts\n\n\t\t\tif (window.location.pathname.match(/.export$/))\n\t\t\t\t$(\"body\").attr(\"id\", \"chart-export\");\n\t\t\t\t\n\t\t\t$(window).one(\"chart-loaded\", function() {\n\t\t\t\tApp.ChartView.onResize(function() {\n\t\t\t\t\tif (window.callPhantom) {\n\t\t\t\t\t\twindow.callPhantom();\n\t\t\t\t\t\tApp.ChartView.onSVGExport();\n\t\t\t\t\t} else {\n\t\t\t\t\t\twindow.top.postMessage(\"chartLoaded\", \"*\");\n\t\t\t\t\t\tconsole.log(\"Loaded chart: \" + App.ChartModel.get(\"chart-name\"));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Keep the query params separate between map and the other tabs\n\t\t\tthis.lastTabName = null;\n\t\t\tthis.mapQueryStr = \"?\";\n\t\t\tthis.chartQueryStr = \"?\";\n\t\t\tthis.originalDefaultTab = App.ChartModel.get(\"default-tab\");\n\n\t\t\t$(window).on(\"query-change\", this.onQueryChange.bind(this));\n\t\t\toptions.dispatcher.on(\"tab-change\", this.onTabChange, this);\n\t\t\tApp.ChartModel.on(\"change:selected-countries\", this.updateCountryParam, this);\t\t\t\n\t\t\tApp.ChartModel.on(\"change-map-year\", this.updateYearParam, this);\n\t\t\tApp.ChartModel.on(\"change-map\", this.updateMapParams, this);\n\t\t\tApp.ChartModel.on(\"change:currentStackMode\", this.updateStackMode, this);\n\t\t\tthis.populateFromURL();\n\t\t},\n\n\t\t/**\n\t\t * Apply any url query parameters on chart startup\n\t\t */\n\t\tpopulateFromURL: function() {\n\t\t\tvar params = owid.getQueryParams();\n\n\t\t\t// Set tab if specified\n\t\t\tvar tab = params.tab;\n\t\t\tif (tab) {\n\t\t\t\tif (!_.contains(App.ChartModel.get(\"tabs\"), tab))\n\t\t\t\t\tconsole.error(\"Unexpected tab: \" + tab);\n\t\t\t\telse\n\t\t\t\t\tApp.ChartModel.set(\"default-tab\", tab, { silent: true });\n\t\t\t}\n\n\t\t\tvar stackMode = params.stackMode;\n\t\t\tif (stackMode == \"relative\")\n\t\t\t\tApp.ChartModel.set(\"currentStackMode\", stackMode);\n\n\t\t\t// Map stuff below\n\n\t\t\tvar year = params.year;\n\t\t\tif (year !== undefined) {\n\t\t\t\tApp.ChartModel.updateMapConfig(\"defaultYear\", year);\n\t\t\t}\n\n\t\t\tvar region = params.region;\n\t\t\tif (region !== undefined) {\n\t\t\t\tApp.ChartModel.updateMapConfig(\"defaultProjection\", region);\n\t\t\t}\n\n\t\t\tvar colorblind = params.colorblind;\n\t\t\tif (colorblind == 1) {\n\t\t\t\tApp.ChartModel.updateMapConfig(\"isColorblind\", true);\n\t\t\t}\n\n\t\t\tvar interpolate = params.interpolate;\n\t\t\tif (interpolate == 0) {\n\t\t\t\tApp.ChartModel.updateMapConfig(\"mode\", \"no-interpolation\");\n\t\t\t}\t\t\t\n\n\t\t\t// TODO: 'country' is currently done server-side, might be more consistent\n\t\t\t// to do them here too - mispy\n\t\t},\n\n\t\t/**\n\t\t * Save the current tab the user is on, and keep url params correctly isolated\n\t\t */\n\t\tonTabChange: function(tabName) {\n\t\t\tif (this.lastTabName == \"map\" && tabName != \"map\") {\n\t\t\t\tthis.mapQueryStr = window.location.search;\n\t\t\t\towid.setQueryStr(this.chartQueryStr);\n\t\t\t} else if (this.lastTabName != \"map\" && this.lastTabName != null && tabName == \"map\") {\t\t\t\t\n\t\t\t\tthis.chartQueryStr = window.location.search;\n\t\t\t\towid.setQueryStr(this.mapQueryStr);\n\t\t\t}\n\t\t\tif (tabName == this.originalDefaultTab)\n\t\t\t\towid.setQueryVariable(\"tab\", null);\n\t\t\telse\n\t\t\t\towid.setQueryVariable(\"tab\", tabName);\n\t\t\tthis.lastTabName = tabName;\n\t\t},\n\n\t\tonQueryChange: function() {\n\t\t},\n\n\t\t/**\n\t\t * Set e.g. &country=AFG+USA when user adds Afghanistan and the United States\n\t\t * using the legend add country buttons\n\t\t */\n\t\tupdateCountryParam: function() {\n\t\t\tvar selectedCountries = App.ChartModel.get(\"selected-countries\"),\n\t\t\t\tentityCodes = [];\n\n\t\t\tApp.DataModel.ready(function(variableData) {\n\t\t\t\t// Sort them by name so the order in the url matches the legend\n\t\t\t\tvar sortedCountries = _.sortBy(selectedCountries, function(entity) {\n\t\t\t\t\treturn entity.name;\n\t\t\t\t});\n\n\t\t\t\tvar entityCodes = [];\n\t\t\t\t_.each(sortedCountries, function(entity) {\n\t\t\t\t\tvar foundEntity = variableData.entityKey[entity.id];\n\t\t\t\t\tif (!foundEntity) return;\n\t\t\t\t\tentityCodes.push(encodeURIComponent(foundEntity.code || foundEntity.name));\n\t\t\t\t});\n\n\t\t\t\towid.setQueryVariable(\"country\", entityCodes.join(\"+\"));\n\t\t\t});\t\t\t\n\t\t},\n\n\t\t/**\n\t\t * Set e.g. &year=1990 when the user uses the map slider to go to 1990\n\t\t */\n\t\tupdateYearParam: function() {\n\t\t\tvar targetYear = App.ChartModel.get(\"map-config\").targetYear;\n\t\t\towid.setQueryVariable(\"year\", targetYear);\n\t\t},\n\n\t\t/**\n\t\t * Store current projection in URL\n\t\t */\n\t\tupdateMapParams: function() {\n\t\t\tvar mapConfig = App.ChartModel.get(\"map-config\");\n\n\t\t\tvar projection = mapConfig.projection;\n\t\t\towid.setQueryVariable(\"region\", projection);\n\n\t\t\tvar colorblind = mapConfig.isColorblind;\n\t\t\tif (colorblind)\n\t\t\t\towid.setQueryVariable(\"colorblind\", 1);\n\t\t\telse\n\t\t\t\towid.setQueryVariable(\"colorblind\", null);\n\n\t\t\tvar interpolate = (mapConfig.mode !== \"no-interpolation\");\n\t\t\tif (interpolate)\n\t\t\t\towid.setQueryVariable(\"interpolate\", null);\n\t\t\telse\n\t\t\t\towid.setQueryVariable(\"interpolate\", 0);\n\t\t},\n\n\t\t/**\n\t\t * Special config for stacked area charts\n\t\t */\n\t\tupdateStackMode: function() {\n\t\t\tvar stackMode = App.ChartModel.get(\"currentStackMode\");\n\t\t\tif (stackMode == \"relative\")\n\t\t\t\towid.setQueryVariable(\"stackMode\", \"relative\");\n\t\t\telse\n\t\t\t\towid.setQueryVariable(\"stackMode\", null);\n\t\t},\n\t});\n})();",";(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.Views.ChartView\");\n\n\tvar Header = require(\"App.Views.Chart.Header\"),\n\t\tFooter = require(\"App.Views.Chart.Footer\"),\n\t\tChartURL = require(\"App.Views.ChartURL\"),\n\t\tScaleSelectors = require(\"App.Views.Chart.ScaleSelectors\"),\n\t\tChartTab = require(\"App.Views.Chart.ChartTab\"),\n\t\tDataTab = require(\"App.Views.Chart.DataTab\"),\n\t\tSourcesTab = require(\"App.Views.Chart.SourcesTab\"),\n\t\tMapTab = require(\"App.Views.Chart.MapTab\"),\n\t\tChartDataModel = require(\"App.Models.ChartDataModel\"),\n\t\tUtils = require(\"App.Utils\");\n\t\n\tApp.Views.ChartView = Backbone.View.extend({\n\t\tactiveTab: false,\n\t\tel: \"#chart-view\",\n\n\t\tevents: {\n\t\t\t\"click li.header-tab a\": \"onTabClick\"\n\t\t},\n\n\t\tinitialize: function(options) {\n\t\t\tApp.ChartView = this;\t\t\t\n\n\t\t\toptions = options || {};\n\t\t\tthis.dispatcher = options.dispatcher || _.clone(Backbone.Events);\n\t\t\n\t\t\t$(document).ajaxStart(function() {\n\t\t\t\t$(\".chart-preloader\").show();\n\t\t\t});\n\n\t\t\t$(document).ajaxStop(function() {\n\t\t\t\t$(\".chart-preloader\").hide();\n\t\t\t});\n\n\t\t\tif (App.ChartModel.get(\"chart-name\"))\n\t\t\t\t$(\".chart-preloader\").show();\n\n\t\t\tif (window.self != window.top) {\n\t\t\t\t$(\"#chart-view\").addClass(\"embedded\");\n\t\t\t}\n\t\t\t\n\t\t\t// Determine if we're logged in and show the edit button\n\t\t\t// Done here instead of PHP to allow for caching etc optimization on public-facing content\n\t\t\tif (Cookies.get(\"wp-settings-11\")) {\n\t\t\t\t$(\".edit-btn-wrapper\").removeClass(\"hidden\");\n\t\t\t}\n\t\t\t\n\t\t\tvar that = this;\n\n\t\t\t// Data model used for fetching variables\n\t\t\tApp.DataModel = new ChartDataModel();\t\t\t\n\t\t\tvar childViewOptions = { dispatcher: this.dispatcher, parentView: this };\n\t\t\tthis.urlBinder = new ChartURL(childViewOptions);\n\t\t\tthis.header = new Header(childViewOptions);\n\t\t\tthis.footer = new Footer(childViewOptions);\n\t\t\tthis.scaleSelectors = new ScaleSelectors(childViewOptions);\n\t\t\t//tabs\n\t\t\tvar chartType = App.ChartModel.get(\"chart-type\");\n\t\t\tthis.chartTab = new ChartTab(childViewOptions);\n\t\t\tthis.dataTab = new DataTab(childViewOptions);\n\t\t\tthis.sourcesTab = new SourcesTab(childViewOptions);\n\t\t\tthis.mapTab = new MapTab(childViewOptions);\n\t\t\tthis.tabs = [this.chartTab, this.dataTab, this.sourcesTab, this.mapTab];\n\t\t\t\n\t\t\tthis.$error = this.$el.find( \".chart-error\" );\n\n\t\t\tnv.utils.windowResize(_.debounce(function() {\n\t\t\t\tthis.onResize();\n\t\t\t}.bind(this), 150));\t\t\t\n\n\t\t\tvar defaultTabName = App.ChartModel.get(\"default-tab\");\n\t\t\tthis.activateTab(defaultTabName);\n\n\t\t\tApp.ChartModel.on(\"change\", function() {\n\t\t\t\t// When the model changes and there's been an error, rebuild the whole current tab\n\t\t\t\t// Allows the editor to recover from failure states\n\t\t\t\tif ($(\".chart-error\").length != 0) {\n\t\t\t\t\tthis.activateTab(this.activeTabName);\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t},\n\n\t\tonTabClick: function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tvar tabName = $(ev.target).closest(\"li\").attr(\"class\").match(/(\\w+)-header-tab/)[1];\n\t\t\tthis.activateTab(tabName);\n\t\t},\n\n\t\tactivateTab: function(tabName) {\n\t\t\t$(\".chart-error\").remove();\n\n\t\t\t$(\".\" + tabName + \"-header-tab a\").tab('show');\n\t\t\tvar tab = this[tabName + \"Tab\"];\n\t\t\tif (this.activeTab) {\n\t\t\t\tthis.activeTab.deactivate();\n\t\t\t\tthis.activeTab = null;\n\t\t\t} else if (this.loadingTab) {\n\t\t\t\tthis.loadingTab.deactivate();\t\t\t\t\n\t\t\t}\n\n\t\t\tthis.loadingTab = tab;\n\t\t\tthis.activeTabName = tabName;\n\t\t\tthis.dispatcher.trigger(\"tab-change\", tabName);\t\t\n\t\t\tif (!_.isEmpty(App.ChartModel.get(\"chart-dimensions\")))\n\t\t\t\t$(\".chart-preloader\").show();\t\t\t\n\t\t\tApp.DataModel.ready(function() {\n\t\t\t\ttry {\n\t\t\t\t\ttab.activate(function() {\n\t\t\t\t\t\t$(\".chart-preloader\").hide();\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.loadingTab = null;\n\t\t\t\t\t\t\tthis.activeTab = tab;\n\t\t\t\t\t\tthis.onResize();\n\t\t\t\t\t}.bind(this));\t\t\t\t\t\n\t\t\t\t} catch (err) {\n\t\t\t\t\tApp.ChartView.handleError(err);\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t},\n\n\t\thandleError: function(err) {\n\t\t\tif (err.responseText) {\n\t\t\t\terr = err.status + \" \" + err.statusText + \"\\n\" + \"    \" + err.responseText;\n\t\t\t} else {\n\t\t\t\terr = err.stack;\n\t\t\t}\n\t\t\tconsole.error(err);\n\t\t\tvar tab = this.activeTab || this.loadingTab;\n\t\t\tif (tab)\n\t\t\t\ttab.deactivate();\n\t\t\tthis.activeTab = null;\n\t\t\tthis.loadingTab = null;\n\t\t\tthis.$(\".chart-preloader\").hide();\n\t\t\tthis.$(\".tab-pane.active\").prepend('<div class=\"chart-error\"><pre>' + err + '</pre></div>');\n\t\t},\n\n\t\tonSVGExport: function() {\t\n\t\t\tvar svg = d3.select(\"svg\");\n\n\t\t\t// Remove SVG UI elements that aren't needed for export\n\t\t\tsvg.selectAll(\".nv-add-btn, .nv-controlsWrap\").remove();\n\n\t\t\t// Inline the CSS styles, since the exported SVG won't have a stylesheet\n\t\t\tvar styleSheets = document.styleSheets;\n\t\t\t_.each(document.styleSheets, function(styleSheet) {\n\t\t\t\t_.each(styleSheet.cssRules, function(rule) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t$(rule.selectorText).each(function(i, elem) {\n\t\t\t\t\t\t\tif ($(elem).parent().closest(\"svg\").length)\n\t\t\t\t\t\t\t\telem.style.cssText += rule.style.cssText;\n\t\t\t\t\t\t});\t\n\t\t\t\t\t} catch (e) {}\t\t\t\t\t\t\n\t\t\t\t});\n\t\t\t});\t\t\n\n\t\t\t// MISPY: Need to propagate a few additional styles from the external document into the SVG\n\t\t\t$(\"svg\").css(\"font-size\", $(\"html\").css(\"font-size\"));\t\n\t\t\t$(\"svg\").css(\"margin\", \"10px\");\n\n\t\t\tsvgAsDataUri(svg.node(), {}, function(uri) {\n\t\t\t\tvar svg = uri.substring('data:image/svg+xml;base64,'.length);\n\t\t\t\tif (_.isFunction(window.callPhantom))\n\t\t\t\t\twindow.callPhantom({ \"svg\": window.atob(svg) });\n\t\t\t});\n\t\t},\n\n\t\tonResize: function(callback, isRepeat) {\n\t\t\tvar $wrapper = this.$el.find(\".chart-wrapper-inner\"),\n\t\t\t\tsvg = d3.select(\"svg\");\n\t\t\tif (!isRepeat) {\n\t\t\t\t$wrapper.css(\"height\", \"calc(100% - 24px)\");\n\t\t\t}\n\n\t\t\tasync.series([this.header.onResize.bind(this.header), \n\t\t\t\t\t\t this.footer.onResize.bind(this.footer)], \n\t\t\tfunction() {\n\t\t\t\t// Figure out how much space we have left for the actual tab content\n\t\t\t\tvar svgBounds = svg.node().getBoundingClientRect(),\n\t\t\t\t\theaderBounds = svg.select(\".chart-header-svg\").node().getBoundingClientRect(),\n\t\t\t\t\tfooterBounds = svg.select(\".chart-footer-svg\").node().getBoundingClientRect(),\n\t\t\t\t\ttabOffsetY = headerBounds.bottom - svgBounds.top,\n\t\t\t\t\ttabHeight = footerBounds.top - headerBounds.bottom;\n\n\t\t\t\t// MISPY: Ideally we want to fit all of our contents into the space that we are given.\n\t\t\t\t// However, if there is much header and footer text and the screen is small then we may\n\t\t\t\t// need to demand extra scrollable height so that the user can actually see the chart.\n\t\t\t\tvar minHeight = 300;\n\t\t\t\tif (tabHeight < minHeight) {\n\t\t\t\t\t//svg.style(\"height\", svgBounds.height + (minHeight-tabHeight) + \"px\");\n\t\t\t\t\t$wrapper.css(\"height\", $wrapper.height() + (minHeight-tabHeight) + 10 + \"px\");\n\t\t\t\t\tthis.onResize(callback, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.$el.find(\".tab-content\").css(\"margin-top\", tabOffsetY);\n\t\t\t\tthis.$el.find(\".tab-content\").css(\"height\", tabHeight);\n\n\t\t\t\tif (this.$el.find(\".chart-tabs\").is(\":visible\")) {\n\t\t\t\t\ttabOffsetY += this.$el.find(\".chart-tabs\").height();\n\t\t\t\t\ttabHeight -= this.$el.find(\".chart-tabs\").height();\n\t\t\t\t}\n\n\t\t\t\tthis.$el.find(\".tab-pane\").css(\"height\", \"calc(100% - \" + $(\".tab-content > .clearfix\").height() + \"px)\");\n\n\t\t\t\tif (this.activeTab && this.activeTab.onResize) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.activeTab.onResize(callback);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tApp.ChartView.handleError(err);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tif (callback) callback();\n\t\t\t}.bind(this));\n\t\t},\n\t});\n})();","\n;(function() {\t\n\t\"use strict\";\n\towid.namespace(\"App.ChartView\");\n\tApp.isEditor = false;\n\n\tApp.loadChart = function(chartConfig) {\n\t\tvar\tChartView = App.Views.ChartView,\n\t\t\tChartModel = App.Models.ChartModel,\n\t\t\tChartDataModel = App.Models.ChartDataModel;\n\n\t\tvar $chartShowWrapper = $(\".chart-show-wrapper, .chart-edit-wrapper\"),\n\t\t\tchartId = $chartShowWrapper.attr(\"data-chart-id\");\n\n\t\tif (!$chartShowWrapper.length || !chartId)\n\t\t\treturn; // No chart to show here\n\n\t\tApp.ChartModel = new ChartModel(chartConfig);\n\t\tApp.ChartView = new App.Views.ChartView();\n\n\t\t//find out if it's in cache\n\t\tif( !$( \".standalone-chart-viewer\" ).length ) {\n\t\t\t//disable caching for viewing within admin\n\t\t\tApp.ChartModel.set( \"cache\", false );\n\t\t}\n\n\t\t//chosen select\n\t\t$( \".chosen-select\" ).chosen();\t\t\n\t}\n})();"],"sourceRoot":"/source/"}